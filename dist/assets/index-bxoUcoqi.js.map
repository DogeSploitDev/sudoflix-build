{"version":3,"mappings":"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,MACA,QAASC,GACTC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,UACAC,SACAC,OACAC,UACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,OACAC,MACA,QAASC,GACT,QAASC,GACTC,MACAC,MACAC,MACAC,MACAC,MACAC,MACA7gB,MACA8gB,MACAC,MACAC,MACAC,MACA,UAAWC,GACXC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,KACF,EC9FMC,GAAgB,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,EAOnDC,GAA0C,CAC9CpC,GAAI,KACJkC,GAAI,IACN,EAGMG,GAAiC,CACrC,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OAAO,EAUHC,GAA6C,CACjDnC,OAAQ,CACNoC,KAAM,SACNvgB,KAAM,SACNwgB,WAAY,eACd,EACApC,MAAO,CACLmC,KAAM,MACNvgB,KAAM,MACNwgB,WAAY,aACd,EACAnC,IAAK,CACHkC,KAAM,MACNvgB,KAAM,aACNwgB,WAAY,KACd,EACAlC,OAAQ,CACNiC,KAAM,SACNvgB,KAAM,SACNwgB,WAAY,WACd,EACA3B,IAAK,CACH0B,KAAM,MACNvgB,KAAM,YACNwgB,WAAY,YAEhB,EAEA,SAASC,GAAqBhK,EAA0B,CAElDA,OADAA,EAASzG,SAAS,GAAG,GACrByG,EAAS/U,SAAW,EAAU+U,EAEhC4J,GAAqBnI,KAAYnY,KAAE0Q,WAAW,GAAGgG,CAAQ,GAAG,CAAC,GAAKA,CAEtE,CAMO,SAASiK,GAAgCC,EAA+B,aAC7E,MAAMC,EACJD,EAAOjf,SAAW,EACdmf,GAAOC,UAAWH,CAAM,GAAKA,EAAQ,EAAI,EACzCE,UAAOF,EAAQ,EAAI,EACnBI,IAAOH,sBAAKnK,WAALmK,cAAeI,cAAfJ,cAA6B,KAAM,KAC5C,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","names":["MWMediaType","updateId","useBookmarkStore","create","persist","immer","set","bookmarks","updateQueue","removeBookmark","id","s","push","toString","action","tmdbId","addBookmark","meta","type","title","year","releaseYear","poster","updatedAt","Date","now","replaceBookmarks","items","clear","clearUpdateQueue","removeUpdateItem","filter","v","name","storeCallbacks","stores","initializeOldStores","store","internal","Object","values","versions","sort","a","b","version","data","_raw","dataVersion","relevantVersions","mostRecentData","migrate","setItem","key","JSON","stringify","err","console","error","length","save","buildStorageObject","latestVersion","onChange","cb","destroy","makeRaw","getRaw","item","localStorage","getItem","parse","withVersion","forEach","window","structuredClone","get","assertStore","versionListSorted","i","arr","Error","migrations","pop","createVersionedStore","_data","setKey","addVersion","ver","build","storageObject","JW_API_BASE","JW_IMAGE_BASE","mediaTypeToJW","MOVIE","SERIES","JWMediaToMediaType","formatJWMeta","media","season","object_type","seasons","season_number","map","number","original_release_year","replace","undefined","seasonData","episodes","episode_number","APP_VERSION","import","DISCORD_LINK","GITHUB_LINK","TWITTER_LINK","BACKEND_URL","env","TMDB_READ_API_KEY","ONBOARDING_CHROME_EXTENSION_INSTALL_LINK","ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK","ONBOARDING_PROXY_INSTALL_LINK","DMCA_EMAIL","CORS_PROXY_URL","NORMAL_ROUTER","DISALLOWED_IDS","TURNSTILE_KEY","CDN_REPLACEMENTS","HAS_ONBOARDING","ALLOW_AUTOPLAY","coerceUndefined","value","getKeyValue","windowValue","__CONFIG__","getKey","defaultString","conf","PROXY_URLS","split","trim","TMDBContentTypes","allowedExtensionRange","isAllowedExtensionVersion","satisfies","RULE_IDS","PREPARE_STREAM","SET_DOMAINS_HLS","SET_DOMAINS_HLS_AUDIO","isExtensionReady","Promise","resolve","setTimeout","activeExtension","sendMessage","message","payload","arguments","timeout","sendToBackgroundViaRelay","body","then","res","catch","sendExtensionRequest","ops","setDomainRule","sendPage","extensionInfo","isExtensionActiveCached","isExtensionActive","info","success","allowed","hasPermission","useAuthStore","account","backendUrl","proxySet","setAccount","acc","removeAccount","setBackendUrl","setProxySet","urls","setAccountProfile","profile","updateAccount","updateDeviceName","deviceName","getStackTrace","lines","topMessage","stackTraceLines","stack","join","reportProviders","segmentStatusMap","notfound","failure","pending","waiting","scrapeSourceOutputToProviderMetric","providerId","embedId","status","episodeId","episode","seasonId","errorMessage","fullError","scrapeSegmentToProviderMetric","segment","reason","scrapePartsToProviderMetric","order","sources","output","orderItem","source","children","embed","metric","useReportProviders","report","useCallback","metaDataCache","token","setCachedMetadata","getCachedMetadata","setApiToken","newToken","getTokenIfValid","jwtDecode","exp","fetchMetadata","base","mwFetch","flat","scrapeMediaToQueryMedia","extra","episodeNumber","episodeTmdbId","seasonNumber","seasonTmdbId","imdbId","addQueryDataToUrl","url","entries","entry","searchParams","makeProviderUrl","makeUrl","URL","p","scrapeSource","sourceId","scrapeAll","scrapeEmbed","embedUrl","getApiToken","apiToken","isTurnstileInitialized","getTurnstileToken","parseEventInput","inp","connectServerSideEvents","endEvents","parsedUrl","eventSource","EventSource","promReject","promResolve","promise","reject","evt","addEventListener","e","close","errObj","NotFoundError","assign","ev","on","event","originalUrls","types","canParseUrl","isParsedUrlType","includes","parseParams","input","entriesParams","param","part","fromEntries","getParsedUrls","getState","startsWith","match","exec","getProxyUrls","getProviderApiUrls","getBodyTypeFromBody","FormData","URLSearchParams","convertBodyToObject","makeLoadbalancedList","getter","listIndex","fetchers","Math","floor","random","proxyUrl","getLoadbalancedProxyUrl","getLoadbalancedProviderApiUrl","fetchButWithApiTokens","init","headers","Headers","response","fetch","newApiToken","makeLoadBalancedSimpleProxyFetcher","fetcher","makeSimpleProxyFetcher","makeFinalHeaders","readHeaders","lowercasedHeaders","toLowerCase","makeExtensionFetcher","result","bodyType","finalUrl","statusCode","baseFetch","ofetch","retry","_ref","k","encodeURIComponent","singularProxiedFetch","combinedUrl","baseURL","endsWith","slice","params","_ref2","query","_ref3","destination","onResponse","context","tokenHeader","Array","isArray","hook","proxiedFetch","mediaTypeToTMDB","TV","mediaItemTypeToMediaType","TMDBMediaToMediaType","TMDBMediaToMediaItemType","formatTMDBMeta","original_release_date","getFullYear","air_date","formatTMDBMetaToMediaItem","release_date","TMDBIdToUrlId","slugify","lower","strict","mediaItemToId","decodeTMDBId","paramId","prefix","mediaType","tmdbBaseUrl1","tmdbBaseUrl2","apiKey","tmdbHeaders","accept","Authorization","abortOnTimeout","controller","AbortController","abort","signal","encodeURI","multiSearch","results","include_adult","language","page","r","media_type","generateQuickSearchMediaUrl","getMediaDetails","append_to_response","getMediaPoster","posterPath","getEpisodes","getMovieFromExternalId","movie","external_source","movie_results","formatTMDBSearchResult","mediatype","show","poster_path","first_air_date","formatTMDBMetaResult","details","getMetaFromId","external_ids","imdb_id","selectedSeason","find","tmdbmeta","getLegacyMetaFromId","queryType","FetchError","provider","external_id","seasonToScrape","isLegacyUrl","isLegacyMediaType","convertLegacyUrl","urlParts","suffix","movieId","SimpleCache","_storage","initialize","_interval","setInterval","val","expiry","INTERVAL_MS","setCompare","compare","_compare","has","foundValue","expirySeconds","getTime","remove","cache","searchQuery","searchForMedia","formattedResult","movieWithPosters","movieWithoutPosters","sortedresult","concat","normalizeTitle","compareTitle","getMetas","uniqueMedias","oldData","yearsAreClose","abs","mediaMetas","relevantItems","all","Number","relevantItem","mediaId","Boolean","keys","Set","watchedEntry","num","max","migrateV1Bookmarks","old","t","migrateV2Videos","newData","oldWatched","newItem","progress","percentage","watchedAt","series","isNotNull","obj","migrateId","migrateV2Bookmarks","updatedBookmarks","migrateV3Videos","migratedId","clone","typeMap","ANIME","oldBookmarks","newItems","oldBookmark","locales","en","ca","caVl","cs","da","de","fr","it","nl","pl","tr","vi","zh","he","sv","pirate","kitty","uwu","minion","lv","th","ne","ar","es","et","tok","hi","ptbr","ptpt","uk","bg","bn","el","fa","gu","ja","ko","sl","ta","zhhant","is","ru","gl","pa","ro","fi","nv","languageOrder","countryPriority","defaultLanguageCodes","extraLanguages","code","nativeName","populateLanguageCode","getPrettyLanguageNameFromLocale","locale","tag","getTag","iso6393To1","lang","Description","region","regionText","sortLangCodes","langCodes","languagesOrder","reverse","langOrderA","findIndex","langOrderB","localeCompare","getCountryCodeForLocale","Subtag","countryLanguages","getLanguage","_err","priority","iso639_1","countries","prioritizedCountry","code_2","regionSubtag","regionCode","c","code_3","getLocaleInfo","realLocale","extraLang","extras","script","extraStringified","parts","langtag","isRtl","direction","resources","translation","i18n","use","initReactI18next","fallbackLng","interpolation","escapeValue","appLanguageOptions","langObj","useSubtitleStore","enabled","lastSync","lastSelectedLanguage","isOpenSubtitles","overrideCasing","delay","styling","color","backgroundOpacity","size","backgroundBlur","bold","resetSubtitleSpecificSettings","updateStyling","newStyling","min","setLanguage","setIsOpenSubtitles","setCustomSubs","setOverrideCasing","setDelay","importSubtitleLanguage","merge","persisted","current","captionSettings","style","fontSize","backgroundColor","langStore","useLanguageStore","subtitleStore","opacitySplit","parseInt","useVolumeStore","volume","setVolume","useEmpheralVolumeStore","showVolume","setShowVolume","bool","useProgressStore","removeItem","replaceItems","updateItem","duration","watched","migrateV4Videos","oldItem","episodeTitle","ep","getAuthHeaders","authorization","bookmarkMediaToInput","userId","method","seedFromMnemonic","mnemonic","pbkdf2Async","sha256","dkLen","verifyValidMnemonic","validateMnemonic","wordlist","keysFromMnemonic","seed","privateKey","publicKey","forge","pki","ed25519","generateKeyPair","genMnemonic","generateMnemonic","signCode","sign","encoding","bytesToBase64","bytes","util","encode64","String","fromCodePoint","bytesToBase64Url","signChallenge","challengeCode","signature","base64ToBuffer","binary","base64","decode","base64ToStringBuffer","createBuffer","stringBufferToBase64","buffer","getBytes","encryptData","secret","byteLength","iv","cipher","createCipher","start","tagLength","update","finish","encryptedData","mode","decryptData","decipher","createDecipher","importProgress","progressItems","importBookmarks","getLoginChallengeToken","loginAccount","namespace","progressUpdateItemToInput","NaN","progressMediaItemToInputs","flatMap","_","toISOString","setProgress","removeProgress","getRegisterChallengeToken","captchaToken","registerAccount","getSessions","updateSession","sessionId","removeSession","updateSettings","settings","getSettings","bookmarkResponsesToEntries","responses","bookmark","progressResponsesToEntries","getUser","editUser","object","deleteUser","getBookmarks","getProgress","useAuthData","loggedIn","clearBookmarks","clearProgress","setTheme","useThemeStore","setAppLanguage","login","loginResponse","user","session","device","logout","syncData","_user","_session","applicationLanguage","defaultSubtitleLanguage","applicationTheme","proxyUrls","useBackendUrl","useAuth","currentAccount","userDataLogout","userDataLogin","loginData","publicKeyBase64Url","challenge","loginResult","userData","seedBase64","register","registerData","recaptchaToken","registerResult","importData","progressInputs","bookmarkInputs","restore","anyError","AUTH_CHECK_INTERVAL","useAuthRestore","hasRestored","useRef","useInterval","useAsync","finally","useQueryParams","loc","useLocation","queryParams","useMemo","search","useQueryParam","location","navigate","useNavigate","currentValue","parsed","delete","useOverlayStore","transition","routes","anchorPoint","setTransition","newTrans","registerRoute","route","setAnchorPoint","point","splitPath","path","joinPath","useRouterAnchorUpdate","routerActive","anchor","document","getElementById","rect","getBoundingClientRect","h","height","w","width","x","y","useEffect","resizeEvent","removeEventListener","useInternalOverlayRouter","setRoute","makePath","oldRoute","newRoute","from","to","showBackwardsTransition","isCurrentPage","isOverlayActive","preventRouteClear","open","defaultRoute","activeRoute","currentRoute","useOverlayRouter","router","isRouterActive","useIsMobile","horizontal","isMobile","setIsMobile","useState","isMobileCurrent","onResize","innerWidth","useBannerStore","banners","isOnline","isTurnstile","ignoredBannerIds","updateOnline","updateTurnstile","setLocation","showBanner","hideBanner","force","updateHeight","found","useBannerSize","currentLocation","reduce","useRegisterBanner","ref","useMeasure","useOnlineListener","counter","interval","clearInterval","getBackendMeta","createCastingSlice","casting","instance","player","setInstance","setPlayer","setController","setIsCasting","isCasting","interface","qualitySorting","unknown","sortedQualities","getPreferredQuality","availableQualites","qualityPreferences","automaticQuality","lastChosenQuality","chosenQualityIndex","indexOf","nearestChoseQuality","selectQuality","stream","quality","availableQualities","qualities","qualityNameMap","allQualities","qualityToString","useQualityStore","setLastChosenQuality","setAutomaticQuality","playerStatus","IDLE","SCRAPING","PLAYING","SCRAPE_NOT_FOUND","PLAYBACK_ERROR","metaToScrapeMedia","createSourceSlice","audioTracks","captionList","currentQuality","currentAudioTrack","caption","selected","asTrack","setSourceId","setStatus","setMeta","newStatus","hideNextEpisodeBtn","setCaption","display","setSource","captions","startAt","loadableStream","redisplaySource","load","preferredQuality","switchQuality","selectedQuality","time","changeQuality","enableAutomaticQuality","createDisplaySlice","setDisplay","newDisplay","mediaPlaying","isPaused","isPlaying","hasPlayedOnce","isFullscreen","vol","buffered","isLoading","audioTrack","needsTrack","canAirplay","rate","playbackRate","reset","_a","thumbnails","images","VideoPlayerTimeFormat","PlayerHoverState","createInterfaceSlice","hasOpenOverlay","isSeeking","lastVolume","leftControlHovering","isHoveringControls","hovering","NOT_HOVERING","lastHoveringState","volumeChangedWithKeybind","volumeChangedWithKeybindDebounce","timeFormat","REGULAR","shouldStartFromBeginning","setShouldStartFromBeginning","setLastVolume","state","setHasOpenOverlay","setTimeFormat","format","updateInterfaceHovering","newState","setSeeking","seeking","setHoveringLeftControls","setHoveringAnyControls","hideNextEpisodeButton","createPlayingSlice","isDragSeeking","play","pause","createProgressSlice","draggingTime","setDraggingTime","nearestImageAt","at","indexPastTimestamp","index","image","imagePastTimestamp","imageBeforeTimestamp","distanceBefore","distancePast","createThumbnailSlice","resetImages","addImage","img","exactOrPastImageIndex","exactOrPastImage","splice","usePlayerStore","sanitize","DOMPurify","captionIsVisible","end","currentTime","delayedStart","delayedEnd","makeQueId","convertSubtitlesToVtt","text","textTrimmed","vtt","convert","detect","convertSubtitlesToSrt","srt","filterDuplicateCaptionCues","cues","cap","lastCap","isSameAsLast","content","parseVttSubtitles","cue","parseSubtitles","_language","stringToBase64","btoa","TextEncoder","encode","convertSubtitlesToSrtDataurl","convertSubtitlesToObjectUrl","createObjectURL","Blob","convertProviderCaption","needsProxy","hasCorsRestrictions","opensubtitles","subtitleTypeList","list","downloadCache","downloadCaption","cached","extensionResponse","responseType","downloadWebVTT","useCaptions","getHlsCaptionList","getCaptionList","getSubtitleTracks","setSubtitlePreference","selectCaptionById","captionId","captionToSet","srtData","hls","track","fragments","frag","vttCaptions","filtered","subsrt","selectLanguage","disable","selectLastUsedLanguage","toggleLastUsed","selectLastUsedLanguageIfEnabled","useInitializePlayer","useInitializeSource","sourceIdentifier","funRef","usePlayer","progressStore","m","playMedia","startAtOverride","setScrapeStatus","setScrapeNotFound","isSafari","test","navigator","userAgent","cachedVolumeResult","canChangeVolume","timeoutPromise","video","createElement","handler","race","canFullscreenAnyElement","fscreen","fullscreenEnabled","canWebkitFullscreen","canFullscreen","canPictureInPicture","canWebkitPictureInPicture","canPlayHlsNatively","Hls","isSupported","canPlayType","detectExtensionInstall","makePercentageString","toFixed","makePercentage","isClickEvent","getEventX","pageX","changedTouches","useProgressBar","barRef","commit","commitImmediately","mouseDown","setMouseDown","mouseMove","pos","left","offsetWidth","mouseUp","removeAttribute","dragMouseDown","setAttribute","dragging","dragPercentage","formatSeconds","secs","showHours","isNaN","seconds","minutes","hours","paddedSecs","padStart","paddedMins","durationExceedsHour","useVolume","setStoredVolume","toggleVolume","newVolume","toggleMute","extractDomain","hostname","extractDomainsFromStream","playlist","buildHeadersFromStream","preferredHeaders","prepareStream","ruleId","targetDomains","requestHeaders","getProviders","makeProviders","makeStandardFetcher","proxiedFetcher","target","targets","BROWSER_EXTENSION","consistentIpForRequests","BROWSER","getAllProviders","allowedQualitiesMap","allowedQualities","allowedFileTypes","isAllowedQuality","convertRunoutputToSource","out","warn","useEmbedScraping","routerId","request","run","useAsyncFn","providerApiUrl","baseUrlMaker","runEmbedScraper","loading","errored","useSourceScraping","scrapeMedia","runSourceScraper","embeds","embedResult","watching","Menu","Cards","Links","Sections","Misc","usePlayerMeta","setDirectMeta","setPlayerMeta","playerMeta","hasAiredCache","hasAired","date","airDate","isAutoplayAllowed","handleBuffered","mediaErrorMap","getMediaErrorDetails","processCdnLink","replacements","before","after","port","protocol","makeEmitter","listeners","eventName","fn","off","emit","levelConversionMap","hlsLevelToQuality","level","qualityToHlsLevel","hlsLevelsToQualities","levels","makeVideoElementDisplayInterface","videoElement","containerElement","isPausedBeforeSeeking","preferenceQuality","languagePromises","Map","reportLevels","convertedLevels","reportAudioTracks","currentLanguage","languageTrack","currentTrack","label","setupQualityForHls","currentLevel","loadLevel","availableQuality","levelIndex","setupSource","vid","src","maxBufferSize","fragLoadPolicy","default","maxLoadTimeMs","maxTimeToFirstByteMs","errorRetry","maxNumRetry","retryDelayMs","maxRetryDelayMs","timeoutRetry","renderTextTracksNatively","Events","ERROR","fatal","baseurl","stackTrace","errorName","MANIFEST_LOADED","LEVEL_LOADED","chunkUrlsDomains","chunkUrls","AUDIO_TRACK_LOADED","LEVEL_SWITCHED","SUBTITLE_TRACK_LOADED","subtitleTracks","attachMedia","loadSource","errorDetails","muted","availability","unloadSource","destroyVideoElement","fullscreenChange","fullscreenElement","webkitFullscreenElement","getType","newAutomaticQuality","newPreferredQuality","processVideoElement","processContainerElement","container","active","paused","setTime","toggleFullscreen","exitFullscreen","requestFullscreen","webkitEnterFullscreen","togglePictureInPicture","webkitPlayer","webkitSetPresentationMode","webkitPresentationMode","pictureInPictureElement","requestPictureInPicture","exitPictureInPicture","startAirplay","videoPlayer","webkitShowPlaybackTargetPicker","setPlaybackRate","setSubtitleOption","changeAudioTrack","makeChromecastDisplayInterface","listenForEvents","listen","field","cast","framework","RemotePlayerEventType","ANY_CHANGE","stop","metaData","chrome","GenericMediaMetadata","mediaInfo","MediaInfo","contentUrl","streamType","StreamType","BUFFERED","metadata","customData","LoadRequest","autoplay","staticMedia","hlsSegmentFormat","HlsSegmentFormat","FMP4","hlsVideoSegmentFormat","HlsVideoSegmentFormat","getCurrentSession","loadMedia","stopListening","loadOps","newCaption","playOrPause","seek","volumeLevel","setVolumeLevel","CHROMECAST_SENDER_SDK","callbacks","_available","available","isChromecastAvailable","initializeChromecast","__onGCastApiAvailable","isAvailable","appendChild","useChromecastAvailable","setAvailable","categories","endpoint","tvCategories","useDebounce","debouncedValue","setDebouncedValue","clearTimeout","shouldGiveJokeTitle","useRandomTranslation","useTranslation","shouldJoke","defaultTitle","returnObjects","defaultValue","decodeURIComponent","useSearchQuery","useParams","setSearch","updateParams","commitToUrl","generatePath","newSearch","defaultProgress","progressIsCompleted","timeFromEnd","progressIsNotStarted","progressIsAcceptableRange","isFirstEpisodeOfShow","shouldShowProgress","epi","useSlashFocus","listener","activeElement","tagName","preventDefault","focus","useRedirectBack","setCompleted","useOnboardingStore","redirectBack","completeAndRedirect","useNavigateOnboarding","nav","pathname","getExtensionState","useHistoryStore","useHistoryListener","useEffectOnce","useLastNonPlayerLink","lastNonPlayerLink","reversedRoutes"],"ignoreList":[],"sources":["../../src/backend/metadata/types/mw.ts","../../src/stores/bookmarks/index.ts","../../src/stores/__old/migrations.ts","../../src/backend/metadata/types/justwatch.ts","../../src/backend/metadata/justwatch.ts","../../src/setup/constants.ts","../../src/setup/config.ts","../../src/backend/metadata/types/tmdb.ts","../../src/backend/extension/compatibility.ts","../../src/backend/extension/messaging.ts","../../src/stores/auth/index.ts","../../src/backend/helpers/report.ts","../../src/backend/helpers/providerApi.ts","../../src/utils/proxyUrls.ts","../../src/backend/extension/request.ts","../../src/backend/providers/fetchers.ts","../../src/backend/helpers/fetch.ts","../../src/backend/metadata/tmdb.ts","../../src/backend/metadata/getmeta.ts","../../src/utils/cache.ts","../../src/backend/metadata/search.ts","../../src/stores/__old/utils.ts","../../src/stores/__old/watched/migrations/v2.ts","../../src/utils/typeguard.ts","../../src/stores/__old/watched/migrations/v3.ts","../../src/stores/__old/bookmark/store.ts","../../src/assets/languages.ts","../../src/utils/language.ts","../../src/setup/i18n.ts","../../src/stores/subtitles/index.ts","../../src/stores/__old/settings/store.ts","../../src/stores/volume/index.ts","../../src/stores/__old/volume/store.ts","../../src/stores/progress/index.ts","../../src/stores/__old/watched/migrations/v4.ts","../../src/stores/__old/watched/store.ts","../../src/backend/accounts/auth.ts","../../src/backend/accounts/bookmarks.ts","../../src/backend/accounts/crypto.ts","../../src/backend/accounts/import.ts","../../src/backend/accounts/login.ts","../../src/backend/accounts/progress.ts","../../src/backend/accounts/register.ts","../../src/backend/accounts/sessions.ts","../../src/backend/accounts/settings.ts","../../src/backend/accounts/user.ts","../../src/hooks/auth/useAuthData.ts","../../src/hooks/auth/useBackendUrl.ts","../../src/hooks/auth/useAuth.ts","../../src/hooks/auth/useAuthRestore.ts","../../src/hooks/useQueryParams.ts","../../src/stores/overlay/store.ts","../../src/hooks/useOverlayRouter.ts","../../src/hooks/useIsMobile.ts","../../src/stores/banner/index.ts","../../src/hooks/usePing.ts","../../src/backend/accounts/meta.ts","../../src/stores/player/slices/casting.ts","../../src/stores/player/utils/qualities.ts","../../src/stores/quality/index.ts","../../src/stores/player/slices/source.ts","../../src/stores/player/slices/display.ts","../../src/stores/player/slices/interface.ts","../../src/stores/player/slices/playing.ts","../../src/stores/player/slices/progress.ts","../../src/stores/player/slices/thumbnails.ts","../../src/stores/player/store.ts","../../src/components/player/utils/captions.ts","../../src/backend/helpers/subs.ts","../../src/components/player/hooks/useCaptions.ts","../../src/components/player/hooks/useInitializePlayer.ts","../../src/components/player/hooks/usePlayer.ts","../../src/utils/detectFeatures.ts","../../src/hooks/useProgressBar.ts","../../src/utils/formatSeconds.ts","../../src/components/player/hooks/useVolume.ts","../../src/backend/extension/streams.ts","../../src/backend/providers/providers.ts","../../src/components/player/utils/convertRunoutputToSource.ts","../../src/components/player/hooks/useSourceSelection.ts","../../src/components/player/internals/ContextMenu/index.ts","../../src/components/player/hooks/usePlayerMeta.ts","../../src/components/player/utils/aired.ts","../../src/utils/autoplay.ts","../../src/components/player/utils/handleBuffered.ts","../../src/components/player/utils/mediaErrorDetails.ts","../../src/utils/cdn.ts","../../src/utils/events.ts","../../src/components/player/display/base.ts","../../src/components/player/display/chromecast.ts","../../src/setup/chromecast.ts","../../src/hooks/useChromecastAvailable.ts","../../src/utils/discover.ts","../../src/hooks/useDebounce.ts","../../src/hooks/useRandomTranslation.ts","../../src/hooks/useSearchQuery.ts","../../src/stores/progress/utils.ts","../../src/components/player/hooks/useSlashFocus.ts","../../src/pages/onboarding/onboardingHooks.ts","../../src/utils/extension.ts","../../src/stores/history/index.ts"],"sourcesContent":["export enum MWMediaType {\n  MOVIE = \"movie\",\n  SERIES = \"series\",\n  ANIME = \"anime\",\n}\n\nexport type MWSeasonMeta = {\n  id: string;\n  number: number;\n  title: string;\n};\n\nexport type MWSeasonWithEpisodeMeta = {\n  id: string;\n  number: number;\n  title: string;\n  episodes: {\n    id: string;\n    number: number;\n    title: string;\n    air_date: string;\n  }[];\n};\n\ntype MWMediaMetaBase = {\n  title: string;\n  id: string;\n  year?: string;\n  poster?: string;\n};\n\ntype MWMediaMetaSpecific =\n  | {\n      type: MWMediaType.MOVIE | MWMediaType.ANIME;\n      seasons: undefined;\n    }\n  | {\n      type: MWMediaType.SERIES;\n      seasons: MWSeasonMeta[];\n      seasonData: MWSeasonWithEpisodeMeta;\n    };\n\nexport type MWMediaMeta = MWMediaMetaBase & MWMediaMetaSpecific;\n\nexport interface MWQuery {\n  searchQuery: string;\n}\n\nexport interface DetailedMeta {\n  meta: MWMediaMeta;\n  imdbId?: string;\n  tmdbId?: string;\n}\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { PlayerMeta } from \"@/stores/player/slices/source\";\n\nexport interface BookmarkMediaItem {\n  title: string;\n  year?: number;\n  poster?: string;\n  type: \"show\" | \"movie\";\n  updatedAt: number;\n}\n\nexport interface BookmarkUpdateItem {\n  tmdbId: string;\n  title?: string;\n  year?: number;\n  id: string;\n  poster?: string;\n  type?: \"show\" | \"movie\";\n  action: \"delete\" | \"add\";\n}\n\nexport interface BookmarkStore {\n  bookmarks: Record<string, BookmarkMediaItem>;\n  updateQueue: BookmarkUpdateItem[];\n  addBookmark(meta: PlayerMeta): void;\n  removeBookmark(id: string): void;\n  replaceBookmarks(items: Record<string, BookmarkMediaItem>): void;\n  clear(): void;\n  clearUpdateQueue(): void;\n  removeUpdateItem(id: string): void;\n}\n\nlet updateId = 0;\n\nexport const useBookmarkStore = create(\n  persist(\n    immer<BookmarkStore>((set) => ({\n      bookmarks: {},\n      updateQueue: [],\n      removeBookmark(id) {\n        set((s) => {\n          updateId += 1;\n          s.updateQueue.push({\n            id: updateId.toString(),\n            action: \"delete\",\n            tmdbId: id,\n          });\n\n          delete s.bookmarks[id];\n        });\n      },\n      addBookmark(meta) {\n        set((s) => {\n          updateId += 1;\n          s.updateQueue.push({\n            id: updateId.toString(),\n            action: \"add\",\n            tmdbId: meta.tmdbId,\n            type: meta.type,\n            title: meta.title,\n            year: meta.releaseYear,\n            poster: meta.poster,\n          });\n\n          s.bookmarks[meta.tmdbId] = {\n            type: meta.type,\n            title: meta.title,\n            year: meta.releaseYear,\n            poster: meta.poster,\n            updatedAt: Date.now(),\n          };\n        });\n      },\n      replaceBookmarks(items: Record<string, BookmarkMediaItem>) {\n        set((s) => {\n          s.bookmarks = items;\n        });\n      },\n      clear() {\n        set((s) => {\n          s.bookmarks = {};\n        });\n      },\n      clearUpdateQueue() {\n        set((s) => {\n          s.updateQueue = [];\n        });\n      },\n      removeUpdateItem(id: string) {\n        set((s) => {\n          s.updateQueue = [...s.updateQueue.filter((v) => v.id !== id)];\n        });\n      },\n    })),\n    {\n      name: \"__MW::bookmarks\",\n    },\n  ),\n);\n","interface StoreVersion<A> {\n  version: number;\n  migrate?(data: A): any;\n  create?: () => A;\n}\ninterface StoreRet<T> {\n  save: (data: T) => void;\n  get: () => T;\n  _raw: () => any;\n  onChange: (cb: (data: T) => void) => {\n    destroy: () => void;\n  };\n}\n\nexport interface StoreBuilder<T> {\n  setKey: (key: string) => StoreBuilder<T>;\n  addVersion: <A>(ver: StoreVersion<A>) => StoreBuilder<T>;\n  build: () => StoreRet<T>;\n}\n\ninterface InternalStoreData {\n  versions: StoreVersion<any>[];\n  key: string | null;\n}\n\nconst storeCallbacks: Record<string, ((data: any) => void)[]> = {};\nconst stores: Record<string, [StoreRet<any>, InternalStoreData]> = {};\n\nexport async function initializeOldStores() {\n  // migrate all stores\n  for (const [store, internal] of Object.values(stores)) {\n    const versions = internal.versions.sort((a, b) => a.version - b.version);\n\n    const data = store._raw();\n    const dataVersion =\n      data[\"--version\"] && typeof data[\"--version\"] === \"number\"\n        ? data[\"--version\"]\n        : 0;\n\n    // Find which versions need to be used for migrations\n    const relevantVersions = versions.filter((v) => v.version >= dataVersion);\n\n    // Migrate over each version\n    let mostRecentData = data;\n    try {\n      for (const version of relevantVersions) {\n        if (version.migrate) {\n          localStorage.setItem(\n            `BACKUP-v${version.version}-${internal.key}`,\n            JSON.stringify(mostRecentData),\n          );\n          mostRecentData = await version.migrate(mostRecentData);\n        }\n      }\n    } catch (err) {\n      console.error(`FAILED TO MIGRATE STORE ${internal.key}`, err);\n      // reset store to lastest version create\n      mostRecentData =\n        relevantVersions[relevantVersions.length - 1].create?.() ?? {};\n    }\n\n    store.save(mostRecentData);\n  }\n}\n\nfunction buildStorageObject<T>(store: InternalStoreData): StoreRet<T> {\n  const key = store.key ?? \"\";\n  const latestVersion = store.versions.sort((a, b) => b.version - a.version)[0];\n\n  function onChange(cb: (data: T) => void) {\n    if (!storeCallbacks[key]) storeCallbacks[key] = [];\n    storeCallbacks[key].push(cb);\n    return {\n      destroy() {\n        // remove function pointer from callbacks\n        storeCallbacks[key] = storeCallbacks[key].filter((v) => v === cb);\n      },\n    };\n  }\n\n  function makeRaw() {\n    const data = latestVersion.create?.() ?? {};\n    data[\"--version\"] = latestVersion.version;\n    return data;\n  }\n\n  function getRaw() {\n    const item = localStorage.getItem(key);\n    if (!item) return makeRaw();\n    try {\n      return JSON.parse(item);\n    } catch (err) {\n      // we assume user has fucked with the data, give them a fresh store\n      console.error(`FAILED TO PARSE LOCALSTORAGE FOR KEY ${key}`, err);\n      return makeRaw();\n    }\n  }\n\n  function save(data: T) {\n    const withVersion: any = { ...data };\n    withVersion[\"--version\"] = latestVersion.version;\n    localStorage.setItem(key, JSON.stringify(withVersion));\n\n    if (!storeCallbacks[key]) storeCallbacks[key] = [];\n    storeCallbacks[key].forEach((v) => v(window.structuredClone(data)));\n  }\n\n  return {\n    get() {\n      const data = getRaw();\n      delete data[\"--version\"];\n      return data as T;\n    },\n    _raw() {\n      return getRaw();\n    },\n    onChange,\n    save,\n  };\n}\n\nfunction assertStore(store: InternalStoreData) {\n  const versionListSorted = store.versions.sort(\n    (a, b) => a.version - b.version,\n  );\n  versionListSorted.forEach((v, i, arr) => {\n    if (i === 0) return;\n    if (v.version !== arr[i - 1].version + 1)\n      throw new Error(\"Version list of store is not incremental\");\n  });\n  versionListSorted.forEach((v) => {\n    if (v.version < 0) throw new Error(\"Versions cannot be negative\");\n  });\n\n  // version zero must exist\n  if (versionListSorted[0]?.version !== 0)\n    throw new Error(\"Version 0 doesn't exist in version list of store\");\n\n  // max version must have create function\n  if (!store.versions[store.versions.length - 1].create)\n    throw new Error(`Missing create function on latest version of store`);\n\n  // check storage string\n  if (!store.key) throw new Error(\"storage key not set in store\");\n\n  // check if all parts have migratio\n  const migrations = [...versionListSorted];\n  migrations.pop();\n  migrations.forEach((v) => {\n    if (!v.migrate)\n      throw new Error(`Migration missing on version ${v.version}`);\n  });\n}\n\nexport function createVersionedStore<T>(): StoreBuilder<T> {\n  const _data: InternalStoreData = {\n    versions: [],\n    key: null,\n  };\n\n  return {\n    setKey(key) {\n      _data.key = key;\n      return this;\n    },\n    addVersion(ver) {\n      _data.versions.push(ver);\n      return this;\n    },\n    build() {\n      assertStore(_data);\n      const storageObject = buildStorageObject<T>(_data);\n      stores[_data.key ?? \"\"] = [storageObject, _data];\n      return storageObject;\n    },\n  };\n}\n","export type JWContentTypes = \"movie\" | \"show\";\n\nexport type JWSearchQuery = {\n  content_types: JWContentTypes[];\n  page: number;\n  page_size: number;\n  query: string;\n};\n\nexport type JWPage<T> = {\n  items: T[];\n  page: number;\n  page_size: number;\n  total_pages: number;\n  total_results: number;\n};\n\nexport const JW_API_BASE = \"https://apis.justwatch.com\";\nexport const JW_IMAGE_BASE = \"https://images.justwatch.com\";\n\nexport type JWSeasonShort = {\n  title: string;\n  id: number;\n  season_number: number;\n};\n\nexport type JWEpisodeShort = {\n  title: string;\n  id: number;\n  episode_number: number;\n};\n\nexport type JWMediaResult = {\n  title: string;\n  poster?: string;\n  id: number;\n  original_release_year?: number;\n  jw_entity_id: string;\n  object_type: JWContentTypes;\n  seasons?: JWSeasonShort[];\n};\n\nexport type JWSeasonMetaResult = {\n  title: string;\n  id: string;\n  season_number: number;\n  episodes: JWEpisodeShort[];\n};\n\nexport type JWExternalIdType =\n  | \"eidr\"\n  | \"imdb_latest\"\n  | \"imdb\"\n  | \"tmdb_latest\"\n  | \"tmdb\"\n  | \"tms\";\n\nexport interface JWExternalId {\n  provider: JWExternalIdType;\n  external_id: string;\n}\n\nexport interface JWDetailedMeta extends JWMediaResult {\n  external_ids: JWExternalId[];\n}\n","import {\n  JWContentTypes,\n  JWMediaResult,\n  JWSeasonMetaResult,\n  JW_IMAGE_BASE,\n} from \"./types/justwatch\";\nimport { MWMediaMeta, MWMediaType, MWSeasonMeta } from \"./types/mw\";\n\nexport function mediaTypeToJW(type: MWMediaType): JWContentTypes {\n  if (type === MWMediaType.MOVIE) return \"movie\";\n  if (type === MWMediaType.SERIES) return \"show\";\n  throw new Error(\"unsupported type\");\n}\n\nexport function JWMediaToMediaType(type: string): MWMediaType {\n  if (type === \"movie\") return MWMediaType.MOVIE;\n  if (type === \"show\") return MWMediaType.SERIES;\n  throw new Error(\"unsupported type\");\n}\n\nexport function formatJWMeta(\n  media: JWMediaResult,\n  season?: JWSeasonMetaResult,\n): MWMediaMeta {\n  const type = JWMediaToMediaType(media.object_type);\n  let seasons: undefined | MWSeasonMeta[];\n  if (type === MWMediaType.SERIES) {\n    seasons = media.seasons\n      ?.sort((a, b) => a.season_number - b.season_number)\n      .map(\n        (v): MWSeasonMeta => ({\n          id: v.id.toString(),\n          number: v.season_number,\n          title: v.title,\n        }),\n      );\n  }\n\n  return {\n    title: media.title,\n    id: media.id.toString(),\n    year: media.original_release_year?.toString(),\n    poster: media.poster\n      ? `${JW_IMAGE_BASE}${media.poster.replace(\"{profile}\", \"s166\")}`\n      : undefined,\n    type,\n    seasons: seasons as any,\n    seasonData: season\n      ? ({\n          id: season.id.toString(),\n          number: season.season_number,\n          title: season.title,\n          episodes: season.episodes\n            .sort((a, b) => a.episode_number - b.episode_number)\n            .map((v) => ({\n              id: v.id.toString(),\n              number: v.episode_number,\n              title: v.title,\n            })),\n        } as any)\n      : (undefined as any),\n  };\n}\n\nexport function JWMediaToId(media: MWMediaMeta): string {\n  return [\"JW\", mediaTypeToJW(media.type), media.id].join(\"-\");\n}\n\nexport function decodeJWId(\n  paramId: string,\n): { id: string; type: MWMediaType } | null {\n  const [prefix, type, id] = paramId.split(\"-\", 3);\n  if (prefix !== \"JW\") return null;\n  let mediaType;\n  try {\n    mediaType = JWMediaToMediaType(type);\n  } catch {\n    return null;\n  }\n  return {\n    type: mediaType,\n    id,\n  };\n}\n","export const APP_VERSION = import.meta.env.PACKAGE_VERSION;\nexport const DISCORD_LINK = \"https://docs.undi.rest/links/discord\";\nexport const GITHUB_LINK = \"https://github.com/sussy-code/smov\";\nexport const TWITTER_LINK = \"https://twitter.com/SudoFlix\";\nexport const GA_ID = import.meta.env.VITE_GA_ID;\nexport const BACKEND_URL = import.meta.env.VITE_BACKEND_URL;\n// Do it clap??\n","import {\n  APP_VERSION,\n  BACKEND_URL,\n  DISCORD_LINK,\n  GITHUB_LINK,\n  TWITTER_LINK,\n} from \"./constants\";\n\ninterface Config {\n  APP_VERSION: string;\n  GITHUB_LINK: string;\n  DISCORD_LINK: string;\n  DMCA_EMAIL: string;\n  TWITTER_LINK: string;\n  TMDB_READ_API_KEY: string;\n  CORS_PROXY_URL: string;\n  NORMAL_ROUTER: boolean;\n  BACKEND_URL: string;\n  DISALLOWED_IDS: string;\n  TURNSTILE_KEY: string;\n  CDN_REPLACEMENTS: string;\n  HAS_ONBOARDING: string;\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: string;\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: string;\n  ONBOARDING_PROXY_INSTALL_LINK: string;\n  ALLOW_AUTOPLAY: boolean;\n}\n\nexport interface RuntimeConfig {\n  APP_VERSION: string;\n  GITHUB_LINK: string;\n  DISCORD_LINK: string;\n  DMCA_EMAIL: string | null;\n  TWITTER_LINK: string;\n  TMDB_READ_API_KEY: string | null;\n  NORMAL_ROUTER: boolean;\n  PROXY_URLS: string[];\n  BACKEND_URL: string | null;\n  DISALLOWED_IDS: string[];\n  TURNSTILE_KEY: string | null;\n  CDN_REPLACEMENTS: Array<string[]>;\n  HAS_ONBOARDING: boolean;\n  ALLOW_AUTOPLAY: boolean;\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: string | null;\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: string | null;\n  ONBOARDING_PROXY_INSTALL_LINK: string | null;\n}\n\nconst env: Record<keyof Config, undefined | string> = {\n  TMDB_READ_API_KEY: import.meta.env.VITE_TMDB_READ_API_KEY,\n  APP_VERSION: undefined,\n  GITHUB_LINK: undefined,\n  DISCORD_LINK: undefined,\n  TWITTER_LINK: undefined,\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: \"https://docs.undi.rest/extension\",\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK,\n  ONBOARDING_PROXY_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_PROXY_INSTALL_LINK,\n  DMCA_EMAIL: import.meta.env.VITE_DMCA_EMAIL,\n  CORS_PROXY_URL: import.meta.env.VITE_CORS_PROXY_URL,\n  NORMAL_ROUTER: import.meta.env.VITE_NORMAL_ROUTER,\n  BACKEND_URL: import.meta.env.VITE_BACKEND_URL,\n  DISALLOWED_IDS: import.meta.env.VITE_DISALLOWED_IDS,\n  TURNSTILE_KEY: import.meta.env.VITE_TURNSTILE_KEY,\n  CDN_REPLACEMENTS: import.meta.env.VITE_CDN_REPLACEMENTS,\n  HAS_ONBOARDING: import.meta.env.VITE_HAS_ONBOARDING,\n  ALLOW_AUTOPLAY: import.meta.env.VITE_ALLOW_AUTOPLAY,\n};\n\nfunction coerceUndefined(value: string | null | undefined): string | undefined {\n  if (value == null) return undefined;\n  if (value.length === 0) return undefined;\n  return value;\n}\n\n// loads from different locations, in order: environment (VITE_{KEY}), window (public/config.js)\nfunction getKeyValue(key: keyof Config): string | undefined {\n  const windowValue = (window as any)?.__CONFIG__?.[`VITE_${key}`];\n\n  return coerceUndefined(env[key]) ?? coerceUndefined(windowValue) ?? undefined;\n}\n\nfunction getKey(key: keyof Config): string | null;\nfunction getKey(key: keyof Config, defaultString: string): string;\nfunction getKey(key: keyof Config, defaultString?: string): string | null {\n  return getKeyValue(key)?.toString() ?? defaultString ?? null;\n}\n\nexport function conf(): RuntimeConfig {\n  return {\n    APP_VERSION,\n    GITHUB_LINK,\n    DISCORD_LINK,\n    TWITTER_LINK,\n    DMCA_EMAIL: getKey(\"DMCA_EMAIL\"),\n    ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: getKey(\n      \"ONBOARDING_CHROME_EXTENSION_INSTALL_LINK\",\n      \"https://docs.undi.rest/extension\",\n    ),\n    ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: getKey(\n      \"ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK\",\n      \"https://docs.undi.rest/extension\",\n    ),\n    ONBOARDING_PROXY_INSTALL_LINK: getKey(\"ONBOARDING_PROXY_INSTALL_LINK\"),\n    BACKEND_URL: getKey(\"BACKEND_URL\", BACKEND_URL),\n    TMDB_READ_API_KEY: getKey(\"TMDB_READ_API_KEY\"),\n    PROXY_URLS: getKey(\"CORS_PROXY_URL\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0),\n    NORMAL_ROUTER: getKey(\"NORMAL_ROUTER\", \"false\") === \"true\",\n    HAS_ONBOARDING: getKey(\"HAS_ONBOARDING\", \"false\") === \"true\",\n    ALLOW_AUTOPLAY: getKey(\"ALLOW_AUTOPLAY\", \"false\") === \"true\",\n    TURNSTILE_KEY: getKey(\"TURNSTILE_KEY\"),\n    DISALLOWED_IDS: getKey(\"DISALLOWED_IDS\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0), // Should be comma-seperated and contain the media type and ID, formatted like so: movie-753342,movie-753342,movie-753342\n    CDN_REPLACEMENTS: getKey(\"CDN_REPLACEMENTS\", \"\")\n      .split(\",\")\n      .map((v) =>\n        v\n          .split(\":\")\n          .map((s) => s.trim())\n          .filter((s) => s.length > 0),\n      )\n      .filter((v) => v.length === 2), // The format is <beforeA>:<afterA>,<beforeB>:<afterB>\n  };\n}\n","export enum TMDBContentTypes {\n  MOVIE = \"movie\",\n  TV = \"tv\",\n}\n\nexport type TMDBSeasonShort = {\n  title: string;\n  id: number;\n  season_number: number;\n};\n\nexport type TMDBEpisodeShort = {\n  title: string;\n  id: number;\n  episode_number: number;\n  air_date: string;\n};\n\nexport type TMDBMediaResult = {\n  title: string;\n  poster?: string;\n  id: number;\n  original_release_date?: Date;\n  object_type: TMDBContentTypes;\n  seasons?: TMDBSeasonShort[];\n};\n\nexport type TMDBSeasonMetaResult = {\n  title: string;\n  id: string;\n  season_number: number;\n  episodes: TMDBEpisodeShort[];\n};\n\nexport interface TMDBShowData {\n  adult: boolean;\n  backdrop_path: string | null;\n  created_by: {\n    id: number;\n    credit_id: string;\n    name: string;\n    gender: number;\n    profile_path: string | null;\n  }[];\n  episode_run_time: number[];\n  first_air_date: string;\n  genres: {\n    id: number;\n    name: string;\n  }[];\n  homepage: string;\n  id: number;\n  in_production: boolean;\n  languages: string[];\n  last_air_date: string;\n  last_episode_to_air: {\n    id: number;\n    name: string;\n    overview: string;\n    vote_average: number;\n    vote_count: number;\n    air_date: string;\n    episode_number: number;\n    production_code: string;\n    runtime: number | null;\n    season_number: number;\n    show_id: number;\n    still_path: string | null;\n  } | null;\n  name: string;\n  next_episode_to_air: {\n    id: number;\n    name: string;\n    overview: string;\n    vote_average: number;\n    vote_count: number;\n    air_date: string;\n    episode_number: number;\n    production_code: string;\n    runtime: number | null;\n    season_number: number;\n    show_id: number;\n    still_path: string | null;\n  } | null;\n  networks: {\n    id: number;\n    logo_path: string;\n    name: string;\n    origin_country: string;\n  }[];\n  number_of_episodes: number;\n  number_of_seasons: number;\n  origin_country: string[];\n  original_language: string;\n  original_name: string;\n  overview: string;\n  popularity: number;\n  poster_path: string | null;\n  production_companies: {\n    id: number;\n    logo_path: string | null;\n    name: string;\n    origin_country: string;\n  }[];\n  production_countries: {\n    iso_3166_1: string;\n    name: string;\n  }[];\n  seasons: {\n    air_date: string;\n    episode_count: number;\n    id: number;\n    name: string;\n    overview: string;\n    poster_path: string | null;\n    season_number: number;\n  }[];\n  spoken_languages: {\n    english_name: string;\n    iso_639_1: string;\n    name: string;\n  }[];\n  status: string;\n  tagline: string;\n  type: string;\n  vote_average: number;\n  vote_count: number;\n  external_ids: {\n    imdb_id: string | null;\n  };\n}\n\nexport interface TMDBMovieData {\n  adult: boolean;\n  backdrop_path: string | null;\n  belongs_to_collection: {\n    id: number;\n    name: string;\n    poster_path: string | null;\n    backdrop_path: string | null;\n  } | null;\n  budget: number;\n  genres: {\n    id: number;\n    name: string;\n  }[];\n  homepage: string | null;\n  id: number;\n  imdb_id: string | null;\n  original_language: string;\n  original_title: string;\n  overview: string | null;\n  popularity: number;\n  poster_path: string | null;\n  production_companies: {\n    id: number;\n    logo_path: string | null;\n    name: string;\n    origin_country: string;\n  }[];\n  production_countries: {\n    iso_3166_1: string;\n    name: string;\n  }[];\n  release_date: string;\n  revenue: number;\n  runtime: number | null;\n  spoken_languages: {\n    english_name: string;\n    iso_639_1: string;\n    name: string;\n  }[];\n  status: string;\n  tagline: string | null;\n  title: string;\n  video: boolean;\n  vote_average: number;\n  vote_count: number;\n  external_ids: {\n    imdb_id: string | null;\n  };\n}\n\nexport interface TMDBEpisodeResult {\n  season: number;\n  number: number;\n  title: string;\n  ids: {\n    trakt: number;\n    tvdb: number;\n    imdb: string;\n    tmdb: number;\n  };\n}\n\nexport interface TMDBEpisode {\n  air_date: string;\n  episode_number: number;\n  id: number;\n  name: string;\n  overview: string;\n  production_code: string;\n  runtime: number;\n  season_number: number;\n  show_id: number;\n  still_path: string | null;\n  vote_average: number;\n  vote_count: number;\n  crew: any[];\n  guest_stars: any[];\n}\n\nexport interface TMDBSeason {\n  _id: string;\n  air_date: string;\n  episodes: TMDBEpisode[];\n  name: string;\n  overview: string;\n  id: number;\n  poster_path: string | null;\n  season_number: number;\n}\n\nexport interface ExternalIdMovieSearchResult {\n  movie_results: {\n    adult: boolean;\n    backdrop_path: string;\n    id: number;\n    title: string;\n    original_language: string;\n    original_title: string;\n    overview: string;\n    poster_path: string;\n    media_type: string;\n    genre_ids: number[];\n    popularity: number;\n    release_date: string;\n    video: boolean;\n    vote_average: number;\n    vote_count: number;\n  }[];\n  person_results: any[];\n  tv_results: any[];\n  tv_episode_results: any[];\n  tv_season_results: any[];\n}\n\nexport interface TMDBMovieSearchResult {\n  adult: boolean;\n  backdrop_path: string;\n  id: number;\n  title: string;\n  original_language: string;\n  original_title: string;\n  overview: string;\n  poster_path: string;\n  media_type: TMDBContentTypes.MOVIE;\n  genre_ids: number[];\n  popularity: number;\n  release_date: string;\n  video: boolean;\n  vote_average: number;\n  vote_count: number;\n}\n\nexport interface TMDBShowSearchResult {\n  adult: boolean;\n  backdrop_path: string;\n  id: number;\n  name: string;\n  original_language: string;\n  original_name: string;\n  overview: string;\n  poster_path: string;\n  media_type: TMDBContentTypes.TV;\n  genre_ids: number[];\n  popularity: number;\n  first_air_date: string;\n  vote_average: number;\n  vote_count: number;\n  origin_country: string[];\n}\n\nexport interface TMDBSearchResult {\n  page: number;\n  results: (TMDBMovieSearchResult | TMDBShowSearchResult)[];\n  total_pages: number;\n  total_results: number;\n}\n","import { satisfies } from \"semver\";\n\nconst allowedExtensionRange = \"^1.0.2\";\n\nexport function isAllowedExtensionVersion(version: string): boolean {\n  return satisfies(version, allowedExtensionRange);\n}\n","import {\n  MessagesMetadata,\n  sendToBackgroundViaRelay,\n} from \"@plasmohq/messaging\";\n\nimport { isAllowedExtensionVersion } from \"@/backend/extension/compatibility\";\nimport { ExtensionMakeRequestResponse } from \"@/backend/extension/plasmo\";\n\nexport const RULE_IDS = {\n  PREPARE_STREAM: 1,\n  SET_DOMAINS_HLS: 2,\n  SET_DOMAINS_HLS_AUDIO: 3,\n};\n\n// for some reason, about 500 ms is needed after\n// page load before the extension starts responding properly\nconst isExtensionReady = new Promise<void>((resolve) => {\n  setTimeout(() => {\n    resolve();\n  }, 500);\n});\n\nlet activeExtension = false;\n\nasync function sendMessage<MessageKey extends keyof MessagesMetadata>(\n  message: MessageKey,\n  payload: MessagesMetadata[MessageKey][\"req\"] | undefined = undefined,\n  timeout: number = -1,\n) {\n  await isExtensionReady;\n  return new Promise<MessagesMetadata[MessageKey][\"res\"] | null>((resolve) => {\n    if (timeout >= 0) setTimeout(() => resolve(null), timeout);\n    sendToBackgroundViaRelay<\n      MessagesMetadata[MessageKey][\"req\"],\n      MessagesMetadata[MessageKey][\"res\"]\n    >({\n      name: message,\n      body: payload,\n    })\n      .then((res) => {\n        activeExtension = true;\n        resolve(res);\n      })\n      .catch(() => {\n        activeExtension = false;\n        resolve(null);\n      });\n  });\n}\n\nexport async function sendExtensionRequest<T>(\n  ops: MessagesMetadata[\"makeRequest\"][\"req\"],\n): Promise<ExtensionMakeRequestResponse<T> | null> {\n  return sendMessage(\"makeRequest\", ops);\n}\n\nexport async function setDomainRule(\n  ops: MessagesMetadata[\"prepareStream\"][\"req\"],\n): Promise<MessagesMetadata[\"prepareStream\"][\"res\"] | null> {\n  return sendMessage(\"prepareStream\", ops);\n}\n\nexport async function sendPage(\n  ops: MessagesMetadata[\"openPage\"][\"req\"],\n): Promise<MessagesMetadata[\"openPage\"][\"res\"] | null> {\n  return sendMessage(\"openPage\", ops);\n}\n\nexport async function extensionInfo(): Promise<\n  MessagesMetadata[\"hello\"][\"res\"] | null\n> {\n  const message = await sendMessage(\"hello\", undefined, 500);\n  return message;\n}\n\nexport function isExtensionActiveCached(): boolean {\n  return activeExtension;\n}\n\nexport async function isExtensionActive(): Promise<boolean> {\n  const info = await extensionInfo();\n  if (!info?.success) return false;\n  const allowedVersion = isAllowedExtensionVersion(info.version);\n  if (!allowedVersion) return false;\n  return info.allowed && info.hasPermission;\n}\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface Account {\n  profile: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport type AccountWithToken = Account & {\n  sessionId: string;\n  userId: string;\n  token: string;\n  seed: string;\n  deviceName: string;\n};\n\ninterface AuthStore {\n  account: null | AccountWithToken;\n  backendUrl: null | string;\n  proxySet: null | string[];\n  removeAccount(): void;\n  setAccount(acc: AccountWithToken): void;\n  updateDeviceName(deviceName: string): void;\n  updateAccount(acc: Account): void;\n  setAccountProfile(acc: Account[\"profile\"]): void;\n  setBackendUrl(url: null | string): void;\n  setProxySet(urls: null | string[]): void;\n}\n\nexport const useAuthStore = create(\n  persist(\n    immer<AuthStore>((set) => ({\n      account: null,\n      backendUrl: null,\n      proxySet: null,\n      setAccount(acc) {\n        set((s) => {\n          s.account = acc;\n        });\n      },\n      removeAccount() {\n        set((s) => {\n          s.account = null;\n        });\n      },\n      setBackendUrl(v) {\n        set((s) => {\n          s.backendUrl = v;\n        });\n      },\n      setProxySet(urls) {\n        set((s) => {\n          s.proxySet = urls;\n        });\n      },\n      setAccountProfile(profile) {\n        set((s) => {\n          if (s.account) {\n            s.account.profile = profile;\n          }\n        });\n      },\n      updateAccount(acc) {\n        set((s) => {\n          if (!s.account) return;\n          s.account = {\n            ...s.account,\n            ...acc,\n          };\n        });\n      },\n      updateDeviceName(deviceName) {\n        set((s) => {\n          if (!s.account) return;\n          s.account.deviceName = deviceName;\n        });\n      },\n    })),\n    {\n      name: \"__MW::auth\",\n    },\n  ),\n);\n","import { ScrapeMedia } from \"@movie-web/providers\";\nimport { nanoid } from \"nanoid\";\nimport { ofetch } from \"ofetch\";\nimport { useCallback } from \"react\";\n\nimport { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport { ScrapingItems, ScrapingSegment } from \"@/hooks/useProviderScrape\";\nimport { BACKEND_URL } from \"@/setup/constants\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { PlayerMeta } from \"@/stores/player/slices/source\";\n\n// for anybody who cares - these are anonymous metrics.\n// They are just used for figuring out if providers are broken or not\nconst metricsEndpoint = `${BACKEND_URL}/metrics/providers`;\nconst captchaMetricsEndpoint = `${BACKEND_URL}/metrics/captcha`;\nconst batchId = () => nanoid(32);\n\nexport type ProviderMetric = {\n  tmdbId: string;\n  type: string;\n  title: string;\n  seasonId?: string;\n  episodeId?: string;\n  status: \"failed\" | \"notfound\" | \"success\";\n  providerId: string;\n  embedId?: string;\n  errorMessage?: string;\n  fullError?: string;\n};\n\nexport type ScrapeTool = \"default\" | \"custom-proxy\" | \"extension\";\n\nexport function getScrapeTool(): ScrapeTool {\n  if (isExtensionActiveCached()) return \"extension\";\n  const hasProxySet = !!useAuthStore.getState().proxySet;\n  if (hasProxySet) return \"custom-proxy\";\n  return \"default\";\n}\n\nfunction getStackTrace(error: Error, lines: number) {\n  const topMessage = error.toString();\n  const stackTraceLines = (error.stack ?? \"\").split(\"\\n\", lines + 1);\n  stackTraceLines.pop();\n  return `${topMessage}\\n\\n${stackTraceLines.join(\"\\n\")}`;\n}\n\nexport async function reportProviders(items: ProviderMetric[]): Promise<void> {\n  if (!BACKEND_URL) return;\n  return ofetch(metricsEndpoint, {\n    method: \"POST\",\n    body: {\n      items,\n      tool: getScrapeTool(),\n      batchId: batchId(),\n    },\n  });\n}\n\nconst segmentStatusMap: Record<\n  ScrapingSegment[\"status\"],\n  ProviderMetric[\"status\"] | null\n> = {\n  success: \"success\",\n  notfound: \"notfound\",\n  failure: \"failed\",\n  pending: null,\n  waiting: null,\n};\n\nexport function scrapeSourceOutputToProviderMetric(\n  media: PlayerMeta,\n  providerId: string,\n  embedId: string | null,\n  status: ProviderMetric[\"status\"],\n  err: unknown | null,\n): ProviderMetric {\n  const episodeId = media.episode?.tmdbId;\n  const seasonId = media.season?.tmdbId;\n  let error: undefined | Error;\n  if (err instanceof Error) error = err;\n\n  return {\n    status,\n    providerId,\n    title: media.title,\n    tmdbId: media.tmdbId,\n    type: media.type,\n    embedId: embedId ?? undefined,\n    episodeId,\n    seasonId,\n    errorMessage: error?.message,\n    fullError: error ? getStackTrace(error, 5) : undefined,\n  };\n}\n\nexport function scrapeSegmentToProviderMetric(\n  media: ScrapeMedia,\n  providerId: string,\n  segment: ScrapingSegment,\n): ProviderMetric | null {\n  const status = segmentStatusMap[segment.status];\n  if (!status) return null;\n  let episodeId: string | undefined;\n  let seasonId: string | undefined;\n  if (media.type === \"show\") {\n    episodeId = media.episode.tmdbId;\n    seasonId = media.season.tmdbId;\n  }\n  let error: undefined | Error;\n  if (segment.error instanceof Error) error = segment.error;\n\n  return {\n    status,\n    providerId,\n    title: media.title,\n    tmdbId: media.tmdbId,\n    type: media.type,\n    embedId: segment.embedId,\n    episodeId,\n    seasonId,\n    errorMessage: segment.reason ?? error?.message,\n    fullError: error ? getStackTrace(error, 5) : undefined,\n  };\n}\n\nexport function scrapePartsToProviderMetric(\n  media: ScrapeMedia,\n  order: ScrapingItems[],\n  sources: Record<string, ScrapingSegment>,\n): ProviderMetric[] {\n  const output: ProviderMetric[] = [];\n\n  order.forEach((orderItem) => {\n    const source = sources[orderItem.id];\n    orderItem.children.forEach((embedId) => {\n      const embed = sources[embedId];\n      if (!embed.embedId) return;\n      const metric = scrapeSegmentToProviderMetric(media, source.id, embed);\n      if (!metric) return;\n      output.push(metric);\n    });\n\n    const metric = scrapeSegmentToProviderMetric(media, source.id, source);\n    if (!metric) return;\n    output.push(metric);\n  });\n\n  return output;\n}\n\nexport function useReportProviders() {\n  const report = useCallback((items: ProviderMetric[]) => {\n    if (items.length === 0) return;\n    reportProviders(items).catch(() => {});\n  }, []);\n\n  return { report };\n}\n\nexport function reportCaptchaSolve(success: boolean) {\n  if (!BACKEND_URL) return;\n  ofetch(captchaMetricsEndpoint, {\n    method: \"POST\",\n    body: {\n      success,\n    },\n  }).catch(() => {});\n}\n","import { MetaOutput, NotFoundError, ScrapeMedia } from \"@movie-web/providers\";\nimport { jwtDecode } from \"jwt-decode\";\n\nimport { mwFetch } from \"@/backend/helpers/fetch\";\nimport { getTurnstileToken, isTurnstileInitialized } from \"@/stores/turnstile\";\n\nlet metaDataCache: MetaOutput[] | null = null;\nlet token: null | string = null;\n\nexport function setCachedMetadata(data: MetaOutput[]) {\n  metaDataCache = data;\n}\n\nexport function getCachedMetadata(): MetaOutput[] {\n  return metaDataCache ?? [];\n}\n\nexport function setApiToken(newToken: string) {\n  token = newToken;\n}\n\nfunction getTokenIfValid(): null | string {\n  if (!token) return null;\n  try {\n    const body = jwtDecode(token);\n    if (!body.exp) return `jwt|${token}`;\n    if (Date.now() / 1000 < body.exp) return `jwt|${token}`;\n  } catch (err) {\n    // we dont care about parse errors\n  }\n  return null;\n}\n\nexport async function fetchMetadata(base: string) {\n  if (metaDataCache) return;\n  const data = await mwFetch<MetaOutput[][]>(`${base}/metadata`);\n  metaDataCache = data.flat();\n}\n\nfunction scrapeMediaToQueryMedia(media: ScrapeMedia) {\n  let extra: Record<string, string> = {};\n  if (media.type === \"show\") {\n    extra = {\n      episodeNumber: media.episode.number.toString(),\n      episodeTmdbId: media.episode.tmdbId,\n      seasonNumber: media.season.number.toString(),\n      seasonTmdbId: media.season.tmdbId,\n    };\n  }\n\n  return {\n    type: media.type,\n    releaseYear: media.releaseYear.toString(),\n    imdbId: media.imdbId,\n    tmdbId: media.tmdbId,\n    title: media.title,\n    ...extra,\n  };\n}\n\nfunction addQueryDataToUrl(url: URL, data: Record<string, string | undefined>) {\n  Object.entries(data).forEach((entry) => {\n    if (entry[1]) url.searchParams.set(entry[0], entry[1]);\n  });\n}\n\nexport function makeProviderUrl(base: string) {\n  const makeUrl = (p: string) => new URL(`${base}${p}`);\n  return {\n    scrapeSource(sourceId: string, media: ScrapeMedia) {\n      const url = makeUrl(\"/scrape/source\");\n      addQueryDataToUrl(url, scrapeMediaToQueryMedia(media));\n      addQueryDataToUrl(url, { id: sourceId });\n      return url.toString();\n    },\n    scrapeAll(media: ScrapeMedia) {\n      const url = makeUrl(\"/scrape\");\n      addQueryDataToUrl(url, scrapeMediaToQueryMedia(media));\n      return url.toString();\n    },\n    scrapeEmbed(embedId: string, embedUrl: string) {\n      const url = makeUrl(\"/scrape/embed\");\n      addQueryDataToUrl(url, { id: embedId, url: embedUrl });\n      return url.toString();\n    },\n  };\n}\n\nexport async function getApiToken(): Promise<string | null> {\n  let apiToken = getTokenIfValid();\n  if (!apiToken && isTurnstileInitialized()) {\n    apiToken = `turnstile|${await getTurnstileToken()}`;\n  }\n  return apiToken;\n}\n\nfunction parseEventInput(inp: string): any {\n  if (inp.length === 0) return {};\n  return JSON.parse(inp);\n}\n\nexport async function connectServerSideEvents<T>(\n  url: string,\n  endEvents: string[],\n) {\n  const apiToken = await getApiToken();\n\n  // insert token, if its set\n  const parsedUrl = new URL(url);\n  if (apiToken) parsedUrl.searchParams.set(\"token\", apiToken);\n  const eventSource = new EventSource(parsedUrl.toString());\n\n  let promReject: (reason?: any) => void;\n  let promResolve: (value: T) => void;\n  const promise = new Promise<T>((resolve, reject) => {\n    promResolve = resolve;\n    promReject = reject;\n  });\n\n  endEvents.forEach((evt) => {\n    eventSource.addEventListener(evt, (e) => {\n      eventSource.close();\n      promResolve(parseEventInput(e.data));\n    });\n  });\n\n  eventSource.addEventListener(\"token\", (e) => {\n    setApiToken(parseEventInput(e.data));\n  });\n\n  eventSource.addEventListener(\"error\", (err: MessageEvent<any>) => {\n    eventSource.close();\n    if (err.data) {\n      const data = JSON.parse(err.data);\n      let errObj = new Error(\"scrape error\");\n      if (data.name === NotFoundError.name)\n        errObj = new NotFoundError(\"Notfound from server\");\n      Object.assign(errObj, data);\n      promReject(errObj);\n      return;\n    }\n\n    console.error(\"Failed to connect to SSE\", err);\n    promReject(err);\n  });\n\n  eventSource.addEventListener(\"message\", (ev) => {\n    if (!ev) {\n      eventSource.close();\n      return;\n    }\n    setTimeout(() => {\n      promReject(new Error(\"SSE closed improperly\"));\n    }, 1000);\n  });\n\n  return {\n    promise: () => promise,\n    on<Data>(event: string, cb: (data: Data) => void) {\n      eventSource.addEventListener(event, (e) => cb(JSON.parse(e.data)));\n    },\n  };\n}\n","import { conf } from \"@/setup/config\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nconst originalUrls = conf().PROXY_URLS;\nconst types = [\"proxy\", \"api\"] as const;\n\ntype ParsedUrlType = (typeof types)[number];\n\nexport interface ParsedUrl {\n  url: string;\n  type: ParsedUrlType;\n}\n\nfunction canParseUrl(url: string): boolean {\n  try {\n    return !!new URL(url);\n  } catch {\n    return false;\n  }\n}\n\nfunction isParsedUrlType(type: string): type is ParsedUrlType {\n  return types.includes(type as any);\n}\n\n/**\n * Turn a string like \"a=b;c=d;d=e\" into a dictionary object\n */\nfunction parseParams(input: string): Record<string, string> {\n  const entriesParams = input\n    .split(\";\")\n    .map((param) => param.split(\"=\", 2).filter((part) => part.length !== 0))\n    .filter((v) => v.length === 2);\n  return Object.fromEntries(entriesParams);\n}\n\nexport function getParsedUrls() {\n  const urls = useAuthStore.getState().proxySet ?? originalUrls;\n  const output: ParsedUrl[] = [];\n  urls.forEach((url) => {\n    if (!url.startsWith(\"|\")) {\n      if (canParseUrl(url)) {\n        output.push({\n          url,\n          type: \"proxy\",\n        });\n        return;\n      }\n    }\n\n    const match = /^\\|([^|]+)\\|(.*)$/g.exec(url);\n    if (!match || !match[2]) return;\n    if (!canParseUrl(match[2])) return;\n    const params = parseParams(match[1]);\n    const type = params.type ?? \"proxy\";\n\n    if (!isParsedUrlType(type)) return;\n    output.push({\n      url: match[2],\n      type,\n    });\n  });\n\n  return output;\n}\n\nexport function getProxyUrls() {\n  return getParsedUrls()\n    .filter((v) => v.type === \"proxy\")\n    .map((v) => v.url);\n}\n\nexport function getProviderApiUrls() {\n  return getParsedUrls()\n    .filter((v) => v.type === \"api\")\n    .map((v) => v.url);\n}\n","import { ExtensionMakeRequestBodyType } from \"./plasmo\";\n\nexport function getBodyTypeFromBody(\n  body: unknown,\n): ExtensionMakeRequestBodyType {\n  if (typeof body === \"string\") return \"string\";\n  if (body instanceof FormData) return \"FormData\";\n  if (body instanceof URLSearchParams) return \"URLSearchParams\";\n  return \"object\";\n}\n\nexport function convertBodyToObject(body: unknown): any {\n  if (body instanceof FormData || body instanceof URLSearchParams) {\n    return [...body];\n  }\n  return body;\n}\n","import { Fetcher, makeSimpleProxyFetcher } from \"@movie-web/providers\";\n\nimport { sendExtensionRequest } from \"@/backend/extension/messaging\";\nimport { getApiToken, setApiToken } from \"@/backend/helpers/providerApi\";\nimport { getProviderApiUrls, getProxyUrls } from \"@/utils/proxyUrls\";\n\nimport { convertBodyToObject, getBodyTypeFromBody } from \"../extension/request\";\n\nfunction makeLoadbalancedList(getter: () => string[]) {\n  let listIndex = -1;\n  return () => {\n    const fetchers = getter();\n    if (listIndex === -1 || listIndex >= fetchers.length) {\n      listIndex = Math.floor(Math.random() * fetchers.length);\n    }\n    const proxyUrl = fetchers[listIndex];\n    listIndex = (listIndex + 1) % fetchers.length;\n    return proxyUrl;\n  };\n}\n\nexport const getLoadbalancedProxyUrl = makeLoadbalancedList(getProxyUrls);\nexport const getLoadbalancedProviderApiUrl =\n  makeLoadbalancedList(getProviderApiUrls);\n\nasync function fetchButWithApiTokens(\n  input: RequestInfo | URL,\n  init?: RequestInit | undefined,\n): Promise<Response> {\n  const apiToken = await getApiToken();\n  const headers = new Headers(init?.headers);\n  if (apiToken) headers.set(\"X-Token\", apiToken);\n  const response = await fetch(\n    input,\n    init\n      ? {\n          ...init,\n          headers,\n        }\n      : undefined,\n  );\n  const newApiToken = response.headers.get(\"X-Token\");\n  if (newApiToken) setApiToken(newApiToken);\n  return response;\n}\n\nexport function makeLoadBalancedSimpleProxyFetcher() {\n  const fetcher: Fetcher = async (a, b) => {\n    const currentFetcher = makeSimpleProxyFetcher(\n      getLoadbalancedProxyUrl(),\n      fetchButWithApiTokens,\n    );\n    return currentFetcher(a, b);\n  };\n  return fetcher;\n}\n\nfunction makeFinalHeaders(\n  readHeaders: string[],\n  headers: Record<string, string>,\n): Headers {\n  const lowercasedHeaders = readHeaders.map((v) => v.toLowerCase());\n  return new Headers(\n    Object.entries(headers).filter((entry) =>\n      lowercasedHeaders.includes(entry[0].toLowerCase()),\n    ),\n  );\n}\n\nexport function makeExtensionFetcher() {\n  const fetcher: Fetcher = async (url, ops) => {\n    const result = await sendExtensionRequest<any>({\n      url,\n      ...ops,\n      body: convertBodyToObject(ops.body),\n      bodyType: getBodyTypeFromBody(ops.body),\n    });\n    if (!result?.success) throw new Error(`extension error: ${result?.error}`);\n    const res = result.response;\n    return {\n      body: res.body,\n      finalUrl: res.finalUrl,\n      statusCode: res.statusCode,\n      headers: makeFinalHeaders(ops.readHeaders, res.headers),\n    };\n  };\n  return fetcher;\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getApiToken, setApiToken } from \"@/backend/helpers/providerApi\";\nimport { getLoadbalancedProxyUrl } from \"@/backend/providers/fetchers\";\n\ntype P<T> = Parameters<typeof ofetch<T, any>>;\ntype R<T> = ReturnType<typeof ofetch<T, any>>;\n\nconst baseFetch = ofetch.create({\n  retry: 0,\n});\n\nexport function makeUrl(url: string, data: Record<string, string>) {\n  let parsedUrl: string = url;\n  Object.entries(data).forEach(([k, v]) => {\n    parsedUrl = parsedUrl.replace(`{${k}}`, encodeURIComponent(v));\n  });\n  return parsedUrl;\n}\n\nexport function mwFetch<T>(url: string, ops: P<T>[1] = {}): R<T> {\n  return baseFetch<T>(url, ops);\n}\n\nexport async function singularProxiedFetch<T>(\n  proxyUrl: string,\n  url: string,\n  ops: P<T>[1] = {},\n): R<T> {\n  let combinedUrl = ops?.baseURL ?? \"\";\n  if (\n    combinedUrl.length > 0 &&\n    combinedUrl.endsWith(\"/\") &&\n    url.startsWith(\"/\")\n  )\n    combinedUrl += url.slice(1);\n  else if (\n    combinedUrl.length > 0 &&\n    !combinedUrl.endsWith(\"/\") &&\n    !url.startsWith(\"/\")\n  )\n    combinedUrl += `/${url}`;\n  else combinedUrl += url;\n\n  const parsedUrl = new URL(combinedUrl);\n  Object.entries(ops?.params ?? {}).forEach(([k, v]) => {\n    parsedUrl.searchParams.set(k, v);\n  });\n  Object.entries(ops?.query ?? {}).forEach(([k, v]) => {\n    parsedUrl.searchParams.set(k, v);\n  });\n\n  let headers = ops.headers ?? {};\n  const apiToken = await getApiToken();\n  if (apiToken)\n    headers = {\n      ...headers,\n      \"X-Token\": apiToken,\n    };\n\n  return baseFetch<T>(proxyUrl, {\n    ...ops,\n    baseURL: undefined,\n    params: {\n      destination: parsedUrl.toString(),\n    },\n    query: {},\n    headers,\n    onResponse(context) {\n      const tokenHeader = context.response.headers.get(\"X-Token\");\n      if (tokenHeader) setApiToken(tokenHeader);\n\n      if (Array.isArray(ops.onResponse)) {\n        ops.onResponse.forEach((hook) => hook(context));\n      } else {\n        ops.onResponse?.(context);\n      }\n    },\n  });\n}\n\nexport function proxiedFetch<T>(url: string, ops: P<T>[1] = {}): R<T> {\n  return singularProxiedFetch<T>(getLoadbalancedProxyUrl(), url, ops);\n}\n","import slugify from \"slugify\";\n\nimport { conf } from \"@/setup/config\";\nimport { MediaItem } from \"@/utils/mediaTypes\";\n\nimport { MWMediaMeta, MWMediaType, MWSeasonMeta } from \"./types/mw\";\nimport {\n  ExternalIdMovieSearchResult,\n  TMDBContentTypes,\n  TMDBEpisodeShort,\n  TMDBMediaResult,\n  TMDBMovieData,\n  TMDBMovieSearchResult,\n  TMDBSearchResult,\n  TMDBSeason,\n  TMDBSeasonMetaResult,\n  TMDBShowData,\n  TMDBShowSearchResult,\n} from \"./types/tmdb\";\nimport { mwFetch } from \"../helpers/fetch\";\n\nexport function mediaTypeToTMDB(type: MWMediaType): TMDBContentTypes {\n  if (type === MWMediaType.MOVIE) return TMDBContentTypes.MOVIE;\n  if (type === MWMediaType.SERIES) return TMDBContentTypes.TV;\n  throw new Error(\"unsupported type\");\n}\n\nexport function mediaItemTypeToMediaType(type: MediaItem[\"type\"]): MWMediaType {\n  if (type === \"movie\") return MWMediaType.MOVIE;\n  if (type === \"show\") return MWMediaType.SERIES;\n  throw new Error(\"unsupported type\");\n}\n\nexport function TMDBMediaToMediaType(type: TMDBContentTypes): MWMediaType {\n  if (type === TMDBContentTypes.MOVIE) return MWMediaType.MOVIE;\n  if (type === TMDBContentTypes.TV) return MWMediaType.SERIES;\n  throw new Error(\"unsupported type\");\n}\n\nexport function TMDBMediaToMediaItemType(\n  type: TMDBContentTypes,\n): MediaItem[\"type\"] {\n  if (type === TMDBContentTypes.MOVIE) return \"movie\";\n  if (type === TMDBContentTypes.TV) return \"show\";\n  throw new Error(\"unsupported type\");\n}\n\nexport function formatTMDBMeta(\n  media: TMDBMediaResult,\n  season?: TMDBSeasonMetaResult,\n): MWMediaMeta {\n  const type = TMDBMediaToMediaType(media.object_type);\n  let seasons: undefined | MWSeasonMeta[];\n  if (type === MWMediaType.SERIES) {\n    seasons = media.seasons\n      ?.sort((a, b) => a.season_number - b.season_number)\n      .map(\n        (v): MWSeasonMeta => ({\n          title: v.title,\n          id: v.id.toString(),\n          number: v.season_number,\n        }),\n      );\n  }\n\n  return {\n    title: media.title,\n    id: media.id.toString(),\n    year: media.original_release_date?.getFullYear()?.toString(),\n    poster: media.poster,\n    type,\n    seasons: seasons as any,\n    seasonData: season\n      ? {\n          id: season.id.toString(),\n          number: season.season_number,\n          title: season.title,\n          episodes: season.episodes\n            .sort((a, b) => a.episode_number - b.episode_number)\n            .map((v) => ({\n              id: v.id.toString(),\n              number: v.episode_number,\n              title: v.title,\n              air_date: v.air_date,\n            })),\n        }\n      : (undefined as any),\n  };\n}\n\nexport function formatTMDBMetaToMediaItem(media: TMDBMediaResult): MediaItem {\n  const type = TMDBMediaToMediaItemType(media.object_type);\n\n  return {\n    title: media.title,\n    id: media.id.toString(),\n    year: media.original_release_date?.getFullYear() ?? 0,\n    release_date: media.original_release_date,\n    poster: media.poster,\n    type,\n  };\n}\n\nexport function TMDBIdToUrlId(\n  type: MWMediaType,\n  tmdbId: string,\n  title: string,\n) {\n  return [\n    \"tmdb\",\n    mediaTypeToTMDB(type),\n    tmdbId,\n    slugify(title, { lower: true, strict: true }),\n  ].join(\"-\");\n}\n\nexport function TMDBMediaToId(media: MWMediaMeta): string {\n  return TMDBIdToUrlId(media.type, media.id, media.title);\n}\n\nexport function mediaItemToId(media: MediaItem): string {\n  return TMDBIdToUrlId(\n    mediaItemTypeToMediaType(media.type),\n    media.id,\n    media.title,\n  );\n}\n\nexport function decodeTMDBId(\n  paramId: string,\n): { id: string; type: MWMediaType } | null {\n  const [prefix, type, id] = paramId.split(\"-\", 3);\n  if (prefix !== \"tmdb\") return null;\n  let mediaType;\n  try {\n    mediaType = TMDBMediaToMediaType(type as TMDBContentTypes);\n  } catch {\n    return null;\n  }\n  return {\n    type: mediaType,\n    id,\n  };\n}\n\nconst tmdbBaseUrl1 = \"https://api.themoviedb.org/3\";\nconst tmdbBaseUrl2 = \"https://api.tmdb.org/3\";\n\nconst apiKey = conf().TMDB_READ_API_KEY;\n\nconst tmdbHeaders = {\n  accept: \"application/json\",\n  Authorization: `Bearer ${apiKey}`,\n};\n\nfunction abortOnTimeout(timeout: number): AbortSignal {\n  const controller = new AbortController();\n  setTimeout(() => controller.abort(), timeout);\n  return controller.signal;\n}\n\nexport async function get<T>(url: string, params?: object): Promise<T> {\n  if (!apiKey) throw new Error(\"TMDB API key not set\");\n  try {\n    return await mwFetch<T>(encodeURI(url), {\n      headers: tmdbHeaders,\n      baseURL: tmdbBaseUrl1,\n      params: {\n        ...params,\n      },\n      signal: abortOnTimeout(5000),\n    });\n  } catch (err) {\n    return mwFetch<T>(encodeURI(url), {\n      headers: tmdbHeaders,\n      baseURL: tmdbBaseUrl2,\n      params: {\n        ...params,\n      },\n      signal: abortOnTimeout(30000),\n    });\n  }\n}\n\nexport async function multiSearch(\n  query: string,\n): Promise<(TMDBMovieSearchResult | TMDBShowSearchResult)[]> {\n  const data = await get<TMDBSearchResult>(\"search/multi\", {\n    query,\n    include_adult: false,\n    language: \"en-US\",\n    page: 1,\n  });\n  // filter out results that aren't movies or shows\n  const results = data.results.filter(\n    (r) =>\n      r.media_type === TMDBContentTypes.MOVIE ||\n      r.media_type === TMDBContentTypes.TV,\n  );\n  return results;\n}\n\nexport async function generateQuickSearchMediaUrl(\n  query: string,\n): Promise<string | undefined> {\n  const data = await multiSearch(query);\n  if (data.length === 0) return undefined;\n  const result = data[0];\n  const title =\n    result.media_type === TMDBContentTypes.MOVIE ? result.title : result.name;\n\n  return `/media/${TMDBIdToUrlId(\n    TMDBMediaToMediaType(result.media_type),\n    result.id.toString(),\n    title,\n  )}`;\n}\n\n// Conditional type which for inferring the return type based on the content type\ntype MediaDetailReturn<T extends TMDBContentTypes> =\n  T extends TMDBContentTypes.MOVIE\n    ? TMDBMovieData\n    : T extends TMDBContentTypes.TV\n      ? TMDBShowData\n      : never;\n\nexport function getMediaDetails<\n  T extends TMDBContentTypes,\n  TReturn = MediaDetailReturn<T>,\n>(id: string, type: T): Promise<TReturn> {\n  if (type === TMDBContentTypes.MOVIE) {\n    return get<TReturn>(`/movie/${id}`, { append_to_response: \"external_ids\" });\n  }\n  if (type === TMDBContentTypes.TV) {\n    return get<TReturn>(`/tv/${id}`, { append_to_response: \"external_ids\" });\n  }\n  throw new Error(\"Invalid media type\");\n}\n\nexport function getMediaPoster(posterPath: string | null): string | undefined {\n  if (posterPath) return `https://image.tmdb.org/t/p/w342/${posterPath}`;\n}\n\nexport async function getEpisodes(\n  id: string,\n  season: number,\n): Promise<TMDBEpisodeShort[]> {\n  const data = await get<TMDBSeason>(`/tv/${id}/season/${season}`);\n  return data.episodes.map((e) => ({\n    id: e.id,\n    episode_number: e.episode_number,\n    title: e.name,\n    air_date: e.air_date,\n  }));\n}\n\nexport async function getMovieFromExternalId(\n  imdbId: string,\n): Promise<string | undefined> {\n  const data = await get<ExternalIdMovieSearchResult>(`/find/${imdbId}`, {\n    external_source: \"imdb_id\",\n  });\n\n  const movie = data.movie_results[0];\n  if (!movie) return undefined;\n\n  return movie.id.toString();\n}\n\nexport function formatTMDBSearchResult(\n  result: TMDBMovieSearchResult | TMDBShowSearchResult,\n  mediatype: TMDBContentTypes,\n): TMDBMediaResult {\n  const type = TMDBMediaToMediaType(mediatype);\n  if (type === MWMediaType.SERIES) {\n    const show = result as TMDBShowSearchResult;\n    return {\n      title: show.name,\n      poster: getMediaPoster(show.poster_path),\n      id: show.id,\n      original_release_date: new Date(show.first_air_date),\n      object_type: mediatype,\n    };\n  }\n\n  const movie = result as TMDBMovieSearchResult;\n\n  return {\n    title: movie.title,\n    poster: getMediaPoster(movie.poster_path),\n    id: movie.id,\n    original_release_date: new Date(movie.release_date),\n    object_type: mediatype,\n  };\n}\n","import { FetchError } from \"ofetch\";\n\nimport { formatJWMeta, mediaTypeToJW } from \"./justwatch\";\nimport {\n  TMDBIdToUrlId,\n  TMDBMediaToMediaType,\n  formatTMDBMeta,\n  getEpisodes,\n  getMediaDetails,\n  getMediaPoster,\n  getMovieFromExternalId,\n  mediaTypeToTMDB,\n} from \"./tmdb\";\nimport {\n  JWDetailedMeta,\n  JWSeasonMetaResult,\n  JW_API_BASE,\n} from \"./types/justwatch\";\nimport { MWMediaMeta, MWMediaType } from \"./types/mw\";\nimport {\n  TMDBContentTypes,\n  TMDBMediaResult,\n  TMDBMovieData,\n  TMDBSeasonMetaResult,\n  TMDBShowData,\n} from \"./types/tmdb\";\nimport { makeUrl, proxiedFetch } from \"../helpers/fetch\";\n\nexport interface DetailedMeta {\n  meta: MWMediaMeta;\n  imdbId?: string;\n  tmdbId?: string;\n}\n\nexport function formatTMDBMetaResult(\n  details: TMDBShowData | TMDBMovieData,\n  type: MWMediaType,\n): TMDBMediaResult {\n  if (type === MWMediaType.MOVIE) {\n    const movie = details as TMDBMovieData;\n    return {\n      id: details.id,\n      title: movie.title,\n      object_type: mediaTypeToTMDB(type),\n      poster: getMediaPoster(movie.poster_path) ?? undefined,\n      original_release_date: new Date(movie.release_date),\n    };\n  }\n  if (type === MWMediaType.SERIES) {\n    const show = details as TMDBShowData;\n    return {\n      id: details.id,\n      title: show.name,\n      object_type: mediaTypeToTMDB(type),\n      seasons: show.seasons.map((v) => ({\n        id: v.id,\n        season_number: v.season_number,\n        title: v.name,\n      })),\n      poster: getMediaPoster(show.poster_path) ?? undefined,\n      original_release_date: new Date(show.first_air_date),\n    };\n  }\n\n  throw new Error(\"unsupported type\");\n}\n\nexport async function getMetaFromId(\n  type: MWMediaType,\n  id: string,\n  seasonId?: string,\n): Promise<DetailedMeta | null> {\n  const details = await getMediaDetails(id, mediaTypeToTMDB(type));\n\n  if (!details) return null;\n\n  const imdbId = details.external_ids.imdb_id ?? undefined;\n\n  let seasonData: TMDBSeasonMetaResult | undefined;\n\n  if (type === MWMediaType.SERIES) {\n    const seasons = (details as TMDBShowData).seasons;\n\n    let selectedSeason = seasons.find((v) => v.id.toString() === seasonId);\n    if (!selectedSeason) {\n      selectedSeason = seasons.find((v) => v.season_number === 1);\n    }\n\n    if (selectedSeason) {\n      const episodes = await getEpisodes(\n        details.id.toString(),\n        selectedSeason.season_number,\n      );\n\n      seasonData = {\n        id: selectedSeason.id.toString(),\n        season_number: selectedSeason.season_number,\n        title: selectedSeason.name,\n        episodes,\n      };\n    }\n  }\n\n  const tmdbmeta = formatTMDBMetaResult(details, type);\n  if (!tmdbmeta) return null;\n  const meta = formatTMDBMeta(tmdbmeta, seasonData);\n  if (!meta) return null;\n\n  return {\n    meta,\n    imdbId,\n    tmdbId: id,\n  };\n}\n\nexport async function getLegacyMetaFromId(\n  type: MWMediaType,\n  id: string,\n  seasonId?: string,\n): Promise<DetailedMeta | null> {\n  const queryType = mediaTypeToJW(type);\n\n  let data: JWDetailedMeta;\n  try {\n    const url = makeUrl(\"/content/titles/{type}/{id}/locale/en_US\", {\n      type: queryType,\n      id,\n    });\n    data = await proxiedFetch<JWDetailedMeta>(url, { baseURL: JW_API_BASE });\n  } catch (err) {\n    if (err instanceof FetchError) {\n      // 400 and 404 are treated as not found\n      if (err.statusCode === 400 || err.statusCode === 404) return null;\n    }\n    throw err;\n  }\n\n  let imdbId = data.external_ids.find(\n    (v) => v.provider === \"imdb_latest\",\n  )?.external_id;\n  if (!imdbId)\n    imdbId = data.external_ids.find((v) => v.provider === \"imdb\")?.external_id;\n\n  let tmdbId = data.external_ids.find(\n    (v) => v.provider === \"tmdb_latest\",\n  )?.external_id;\n  if (!tmdbId)\n    tmdbId = data.external_ids.find((v) => v.provider === \"tmdb\")?.external_id;\n\n  let seasonData: JWSeasonMetaResult | undefined;\n  if (data.object_type === \"show\") {\n    const seasonToScrape = seasonId ?? data.seasons?.[0].id.toString() ?? \"\";\n    const url = makeUrl(\"/content/titles/show_season/{id}/locale/en_US\", {\n      id: seasonToScrape,\n    });\n    seasonData = await proxiedFetch<any>(url, { baseURL: JW_API_BASE });\n  }\n\n  return {\n    meta: formatJWMeta(data, seasonData),\n    imdbId,\n    tmdbId,\n  };\n}\n\nexport function isLegacyUrl(url: string): boolean {\n  if (url.startsWith(\"/media/JW\") || url.startsWith(\"/media/tmdb-show\"))\n    return true;\n  return false;\n}\n\nexport function isLegacyMediaType(url: string): boolean {\n  if (url.startsWith(\"/media/tmdb-show\")) return true;\n  return false;\n}\n\nexport async function convertLegacyUrl(\n  url: string,\n): Promise<string | undefined> {\n  if (!isLegacyUrl(url)) return undefined;\n\n  const urlParts = url.split(\"/\").slice(2);\n  const [, type, id] = urlParts[0].split(\"-\", 3);\n  const suffix = urlParts\n    .slice(1)\n    .map((v) => `/${v}`)\n    .join(\"\");\n\n  if (isLegacyMediaType(url)) {\n    const details = await getMediaDetails(id, TMDBContentTypes.TV);\n    return `/media/${TMDBIdToUrlId(\n      MWMediaType.SERIES,\n      details.id.toString(),\n      details.name,\n    )}${suffix}`;\n  }\n\n  const mediaType = TMDBMediaToMediaType(type as TMDBContentTypes);\n  const meta = await getLegacyMetaFromId(mediaType, id);\n\n  if (!meta) return undefined;\n  const { tmdbId, imdbId } = meta;\n  if (!tmdbId && !imdbId) return undefined;\n\n  // movies always have an imdb id on tmdb\n  if (imdbId && mediaType === MWMediaType.MOVIE) {\n    const movieId = await getMovieFromExternalId(imdbId);\n    if (movieId) {\n      return `/media/${TMDBIdToUrlId(mediaType, movieId, meta.meta.title)}`;\n    }\n\n    if (tmdbId) {\n      return `/media/${TMDBIdToUrlId(mediaType, tmdbId, meta.meta.title)}`;\n    }\n  }\n}\n","export class SimpleCache<Key, Value> {\n  protected readonly INTERVAL_MS = 2 * 60 * 1000; // 2 minutes\n\n  protected _interval: ReturnType<typeof setTimeout> | null = null;\n\n  protected _compare: ((a: Key, b: Key) => boolean) | null = null;\n\n  protected _storage: { key: Key; value: Value; expiry: Date }[] = [];\n\n  /*\n   ** initialize store, will start the interval\n   */\n  public initialize(): void {\n    if (this._interval) throw new Error(\"cache is already initialized\");\n    this._interval = setInterval(() => {\n      const now = new Date();\n      this._storage.filter((val) => {\n        if (val.expiry < now) return false; // remove if expiry date is in the past\n        return true;\n      });\n    }, this.INTERVAL_MS);\n  }\n\n  /*\n   ** destroy cache instance, its not safe to use the instance after calling this\n   */\n  public destroy(): void {\n    if (this._interval) clearInterval(this._interval);\n    this.clear();\n  }\n\n  /*\n   ** Set compare function, function must return true if A & B are equal\n   */\n  public setCompare(compare: (a: Key, b: Key) => boolean): void {\n    this._compare = compare;\n  }\n\n  /*\n   ** check if cache contains the item\n   */\n  public has(key: Key): boolean {\n    return !!this.get(key);\n  }\n\n  /*\n   ** get item from cache\n   */\n  public get(key: Key): Value | undefined {\n    if (!this._compare) throw new Error(\"Compare function not set\");\n    const foundValue = this._storage.find(\n      (item) => this._compare && this._compare(item.key, key),\n    );\n    if (!foundValue) return undefined;\n    return foundValue.value;\n  }\n\n  /*\n   ** set item from cache, if it already exists, it will overwrite\n   */\n  public set(key: Key, value: Value, expirySeconds: number): void {\n    if (!this._compare) throw new Error(\"Compare function not set\");\n    const foundValue = this._storage.find(\n      (item) => this._compare && this._compare(item.key, key),\n    );\n    const expiry = new Date(new Date().getTime() + expirySeconds * 1000);\n\n    // overwrite old value\n    if (foundValue) {\n      foundValue.key = key;\n      foundValue.value = value;\n      foundValue.expiry = expiry;\n      return;\n    }\n\n    // add new value to storage\n    this._storage.push({\n      key,\n      value,\n      expiry,\n    });\n  }\n\n  /*\n   ** remove item from cache\n   */\n  public remove(key: Key): void {\n    if (!this._compare) throw new Error(\"Compare function not set\");\n    this._storage.filter((val) => {\n      if (this._compare && this._compare(val.key, key)) return false; // remove if compare is success\n      return true;\n    });\n  }\n\n  /*\n   ** clear entire cache storage\n   */\n  public clear(): void {\n    this._storage = [];\n  }\n}\n","import { SimpleCache } from \"@/utils/cache\";\nimport { MediaItem } from \"@/utils/mediaTypes\";\n\nimport {\n  formatTMDBMetaToMediaItem,\n  formatTMDBSearchResult,\n  multiSearch,\n} from \"./tmdb\";\nimport { MWQuery } from \"./types/mw\";\n\nconst cache = new SimpleCache<MWQuery, MediaItem[]>();\ncache.setCompare((a, b) => {\n  return a.searchQuery.trim() === b.searchQuery.trim();\n});\ncache.initialize();\n\nexport async function searchForMedia(query: MWQuery): Promise<MediaItem[]> {\n  if (cache.has(query)) return cache.get(query) as MediaItem[];\n  const { searchQuery } = query;\n\n  const data = await multiSearch(searchQuery);\n  const results = data.map((v) => {\n    const formattedResult = formatTMDBSearchResult(v, v.media_type);\n    return formatTMDBMetaToMediaItem(formattedResult);\n  });\n\n  const movieWithPosters = results.filter((movie) => movie.poster);\n  const movieWithoutPosters = results.filter((movie) => !movie.poster);\n\n  const sortedresult = movieWithPosters.concat(movieWithoutPosters);\n\n  // cache results for 1 hour\n  cache.set(query, sortedresult, 3600);\n  return sortedresult;\n}\n","function normalizeTitle(title: string): string {\n  return title\n    .trim()\n    .toLowerCase()\n    .replace(/['\":]/g, \"\")\n    .replace(/[^a-zA-Z0-9]+/g, \"_\");\n}\n\nexport function compareTitle(a: string, b: string): boolean {\n  return normalizeTitle(a) === normalizeTitle(b);\n}\n","import { DetailedMeta, getMetaFromId } from \"@/backend/metadata/getmeta\";\nimport { searchForMedia } from \"@/backend/metadata/search\";\nimport { mediaItemTypeToMediaType } from \"@/backend/metadata/tmdb\";\nimport { MWMediaMeta, MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { compareTitle } from \"@/stores/__old/utils\";\n\nimport { WatchedStoreData, WatchedStoreItem } from \"../types\";\n\ninterface OldMediaBase {\n  mediaId: number;\n  mediaType: MWMediaType;\n  percentage: number;\n  progress: number;\n  providerId: string;\n  title: string;\n  year: number;\n}\n\ninterface OldMovie extends OldMediaBase {\n  mediaType: MWMediaType.MOVIE;\n}\n\ninterface OldSeries extends OldMediaBase {\n  mediaType: MWMediaType.SERIES;\n  episodeId: number;\n  seasonId: number;\n}\n\nexport interface OldData {\n  items: (OldMovie | OldSeries)[];\n}\n\nexport interface OldBookmarks {\n  bookmarks: (OldMovie | OldSeries)[];\n}\n\nasync function getMetas(\n  uniqueMedias: Record<string, any>,\n  oldData?: OldData,\n): Promise<Record<string, Record<string, DetailedMeta | null>> | undefined> {\n  const yearsAreClose = (a: number, b: number) => {\n    return Math.abs(a - b) <= 1;\n  };\n\n  const mediaMetas: Record<string, Record<string, DetailedMeta | null>> = {};\n\n  const relevantItems = await Promise.all(\n    Object.values(uniqueMedias).map(async (item) => {\n      const year = Number(item.year.toString().split(\"-\")[0]);\n      const data = await searchForMedia({\n        searchQuery: `${item.title} ${year}`,\n      });\n      const relevantItem = data.find(\n        (res) =>\n          yearsAreClose(Number(res.year), year) &&\n          compareTitle(res.title, item.title),\n      );\n      if (!relevantItem) {\n        console.error(`No item found for migration: ${item.title}`);\n        return;\n      }\n      return {\n        id: item.mediaId,\n        data: relevantItem,\n      };\n    }),\n  );\n\n  for (const item of relevantItems.filter(Boolean)) {\n    if (!item) continue;\n\n    let keys: (string | null)[][] = [[\"0\", \"0\"]];\n    if (item.data.type === \"show\") {\n      const meta = await getMetaFromId(MWMediaType.SERIES, item.data.id);\n      if (!meta || !meta?.meta.seasons) return;\n      const seasonNumbers = [\n        ...new Set(\n          oldData?.items\n            ? oldData.items\n                .filter((watchedEntry: any) => watchedEntry.mediaId === item.id)\n                .map((watchedEntry: any) => watchedEntry.seasonId)\n            : [\"0\"],\n        ),\n      ];\n      const seasons = seasonNumbers.map((num) => ({\n        num,\n        season: meta.meta?.seasons?.[Math.max(0, (num as number) - 1)],\n      }));\n      keys = seasons\n        .map((season) => (season ? [season.num, season?.season?.id] : []))\n        .filter((entry) => entry.length > 0);\n    }\n\n    if (!mediaMetas[item.id]) mediaMetas[item.id] = {};\n    await Promise.all(\n      keys.map(async ([key, id]) => {\n        if (!key) return;\n        mediaMetas[item.id][key] = await getMetaFromId(\n          mediaItemTypeToMediaType(item.data.type),\n          item.data.id,\n          id === \"0\" || id === null ? undefined : id,\n        );\n      }),\n    );\n  }\n\n  return mediaMetas;\n}\n\nexport async function migrateV1Bookmarks(old: OldBookmarks) {\n  const oldData = old;\n  if (!oldData) return;\n\n  const uniqueMedias: Record<string, any> = {};\n  oldData.bookmarks.forEach((item: any) => {\n    if (uniqueMedias[item.mediaId]) return;\n    uniqueMedias[item.mediaId] = item;\n  });\n\n  const mediaMetas = await getMetas(uniqueMedias);\n  if (!mediaMetas) return;\n\n  const bookmarks = Object.keys(mediaMetas)\n    .map((key) => mediaMetas[key][\"0\"])\n    .map((t) => t?.meta)\n    .filter(Boolean);\n\n  return {\n    bookmarks,\n  };\n}\n\nexport async function migrateV2Videos(old: OldData) {\n  const oldData = old;\n  if (!oldData) return;\n\n  const uniqueMedias: Record<string, any> = {};\n  oldData.items.forEach((item: any) => {\n    if (uniqueMedias[item.mediaId]) return;\n    uniqueMedias[item.mediaId] = item;\n  });\n\n  const mediaMetas = await getMetas(uniqueMedias, oldData);\n  if (!mediaMetas) return;\n\n  // We've got all the metadata you can dream of now\n  // Now let's convert stuff into the new format.\n  const newData: WatchedStoreData = {\n    ...oldData,\n    items: [],\n  };\n\n  const now = Date.now();\n\n  for (const oldWatched of oldData.items) {\n    if (oldWatched.mediaType === \"movie\") {\n      if (!mediaMetas[oldWatched.mediaId][\"0\"]?.meta) continue;\n\n      const newItem: WatchedStoreItem = {\n        item: {\n          meta: mediaMetas[oldWatched.mediaId][\"0\"]?.meta as MWMediaMeta,\n        },\n        progress: oldWatched.progress,\n        percentage: oldWatched.percentage,\n        watchedAt: Date.now(), // There was no watchedAt in V2\n      };\n\n      oldData.items = oldData.items.filter(\n        (item) => JSON.stringify(item) !== JSON.stringify(oldWatched),\n      );\n      newData.items.push(newItem);\n    } else if (oldWatched.mediaType === \"series\") {\n      if (!mediaMetas[oldWatched.mediaId][oldWatched.seasonId]?.meta) continue;\n\n      const meta = mediaMetas[oldWatched.mediaId][oldWatched.seasonId]\n        ?.meta as MWMediaMeta;\n\n      if (meta.type !== \"series\") return;\n\n      const newItem: WatchedStoreItem = {\n        item: {\n          meta,\n          series: {\n            episode: Number(oldWatched.episodeId),\n            season: Number(oldWatched.seasonId),\n            seasonId: meta.seasonData.id,\n            episodeId:\n              meta.seasonData.episodes[Number(oldWatched.episodeId) - 1].id,\n          },\n        },\n        progress: oldWatched.progress,\n        percentage: oldWatched.percentage,\n        watchedAt:\n          now +\n          Number(oldWatched.seasonId) * 1000 +\n          Number(oldWatched.episodeId), // There was no watchedAt in V2\n        // JANK ALERT: Put watchedAt in the future to show last episode as most recently\n      };\n\n      if (\n        newData.items.find(\n          (item) =>\n            item.item.meta.id === newItem.item.meta.id &&\n            item.item.series?.episodeId === newItem.item.series?.episodeId,\n        )\n      )\n        continue;\n\n      oldData.items = oldData.items.filter(\n        (item) => JSON.stringify(item) !== JSON.stringify(oldWatched),\n      );\n      newData.items.push(newItem);\n    }\n  }\n\n  return newData;\n}\n","export function isNotNull<T>(obj: T | null): obj is T {\n  return obj != null;\n}\n\nexport type ValuesOf<T> = T[keyof T];\n","import { getLegacyMetaFromId } from \"@/backend/metadata/getmeta\";\nimport {\n  getEpisodes,\n  getMediaDetails,\n  getMovieFromExternalId,\n} from \"@/backend/metadata/tmdb\";\nimport { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { TMDBContentTypes } from \"@/backend/metadata/types/tmdb\";\nimport { BookmarkStoreData } from \"@/stores/__old/bookmark/types\";\nimport { isNotNull } from \"@/utils/typeguard\";\n\nimport { WatchedStoreData } from \"../types\";\n\nasync function migrateId(\n  id: string,\n  type: MWMediaType,\n): Promise<string | undefined> {\n  const meta = await getLegacyMetaFromId(type, id);\n\n  if (!meta) return undefined;\n  const { tmdbId, imdbId } = meta;\n  if (!tmdbId && !imdbId) return undefined;\n\n  // movies always have an imdb id on tmdb\n  if (imdbId && type === MWMediaType.MOVIE) {\n    const movieId = await getMovieFromExternalId(imdbId);\n    if (movieId) return movieId;\n  }\n\n  if (tmdbId) {\n    return tmdbId;\n  }\n}\n\nexport async function migrateV2Bookmarks(old: BookmarkStoreData) {\n  const updatedBookmarks = old.bookmarks.map(async (item) => ({\n    ...item,\n    id: await migrateId(item.id, item.type).catch(() => undefined),\n  }));\n\n  return {\n    bookmarks: (await Promise.all(updatedBookmarks)).filter((item) => item.id),\n  };\n}\n\nexport async function migrateV3Videos(\n  old: WatchedStoreData,\n): Promise<WatchedStoreData> {\n  const updatedItems = await Promise.all(\n    old.items.map(async (progress) => {\n      try {\n        const migratedId = await migrateId(\n          progress.item.meta.id,\n          progress.item.meta.type,\n        );\n\n        if (!migratedId) return null;\n\n        const clone = structuredClone(progress);\n        clone.item.meta.id = migratedId;\n        if (clone.item.series) {\n          const series = clone.item.series;\n          const details = await getMediaDetails(\n            migratedId,\n            TMDBContentTypes.TV,\n          );\n\n          const season = details.seasons.find(\n            (v) => v.season_number === series.season,\n          );\n          if (!season) return null;\n\n          const episodes = await getEpisodes(migratedId, season.season_number);\n          const episode = episodes.find(\n            (v) => v.episode_number === series.episode,\n          );\n          if (!episode) return null;\n\n          clone.item.series.episodeId = episode.id.toString();\n          clone.item.series.seasonId = season.id.toString();\n        }\n\n        return clone;\n      } catch (err) {\n        return null;\n      }\n    }),\n  );\n\n  return {\n    items: updatedItems.filter(isNotNull),\n  };\n}\n","import { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { BookmarkMediaItem, useBookmarkStore } from \"@/stores/bookmarks\";\n\nimport { BookmarkStoreData } from \"./types\";\nimport { createVersionedStore } from \"../migrations\";\nimport { OldBookmarks, migrateV1Bookmarks } from \"../watched/migrations/v2\";\nimport { migrateV2Bookmarks } from \"../watched/migrations/v3\";\n\nconst typeMap: Record<MWMediaType, \"show\" | \"movie\" | null> = {\n  [MWMediaType.ANIME]: null,\n  [MWMediaType.MOVIE]: \"movie\",\n  [MWMediaType.SERIES]: \"show\",\n};\n\nexport const BookmarkStore = createVersionedStore<BookmarkStoreData>()\n  .setKey(\"mw-bookmarks\")\n  .addVersion({\n    version: 0,\n    migrate(oldBookmarks: OldBookmarks) {\n      return migrateV1Bookmarks(oldBookmarks);\n    },\n  })\n  .addVersion({\n    version: 1,\n    migrate(old: BookmarkStoreData) {\n      return migrateV2Bookmarks(old);\n    },\n  })\n  .addVersion({\n    version: 2,\n    migrate(old: BookmarkStoreData): BookmarkStoreData {\n      const newItems: Record<string, BookmarkMediaItem> = {};\n\n      for (const oldBookmark of old.bookmarks) {\n        const type = typeMap[oldBookmark.type];\n        if (!type) continue;\n        newItems[oldBookmark.id] = {\n          title: oldBookmark.title,\n          year: oldBookmark.year ? Number(oldBookmark.year) : undefined,\n          poster: oldBookmark.poster,\n          type,\n          updatedAt: Date.now(),\n        };\n      }\n\n      useBookmarkStore.getState().replaceBookmarks(newItems);\n\n      return { bookmarks: [] };\n    },\n  })\n  .addVersion({\n    version: 3,\n    create() {\n      return {\n        bookmarks: [],\n      };\n    },\n  })\n  .build();\n","import ar from \"@/assets/locales/ar.json\";\nimport bg from \"@/assets/locales/bg.json\";\nimport bn from \"@/assets/locales/bn.json\";\nimport ca from \"@/assets/locales/ca.json\";\nimport caVl from \"@/assets/locales/ca@valencia.json\";\nimport cs from \"@/assets/locales/cs.json\";\nimport da from \"@/assets/locales/da.json\";\nimport de from \"@/assets/locales/de.json\";\nimport el from \"@/assets/locales/el.json\";\nimport en from \"@/assets/locales/en.json\";\nimport es from \"@/assets/locales/es.json\";\nimport et from \"@/assets/locales/et.json\";\nimport fa from \"@/assets/locales/fa.json\";\nimport fi from \"@/assets/locales/fi-FI.json\";\nimport fr from \"@/assets/locales/fr.json\";\nimport gl from \"@/assets/locales/gl.json\";\nimport gu from \"@/assets/locales/gu.json\";\nimport he from \"@/assets/locales/he.json\";\nimport hi from \"@/assets/locales/hi.json\";\nimport id from \"@/assets/locales/id.json\";\nimport is from \"@/assets/locales/is-IS.json\";\nimport it from \"@/assets/locales/it.json\";\nimport ja from \"@/assets/locales/ja.json\";\nimport kitty from \"@/assets/locales/kitty.json\";\nimport ko from \"@/assets/locales/ko.json\";\nimport lv from \"@/assets/locales/lv.json\";\nimport minion from \"@/assets/locales/minion.json\";\nimport ne from \"@/assets/locales/ne.json\";\nimport nl from \"@/assets/locales/nl.json\";\nimport nv from \"@/assets/locales/nv.json\";\nimport pa from \"@/assets/locales/pa.json\";\nimport pirate from \"@/assets/locales/pirate.json\";\nimport pl from \"@/assets/locales/pl.json\";\nimport ptbr from \"@/assets/locales/pt-BR.json\";\nimport ptpt from \"@/assets/locales/pt-PT.json\";\nimport ro from \"@/assets/locales/ro.json\";\nimport ru from \"@/assets/locales/ru.json\";\nimport sl from \"@/assets/locales/sl.json\";\nimport sv from \"@/assets/locales/sv.json\";\nimport ta from \"@/assets/locales/ta.json\";\nimport th from \"@/assets/locales/th.json\";\nimport tok from \"@/assets/locales/tok.json\";\nimport tr from \"@/assets/locales/tr.json\";\nimport uk from \"@/assets/locales/uk.json\";\nimport uwu from \"@/assets/locales/uwu.json\";\nimport vi from \"@/assets/locales/vi.json\";\nimport zhhant from \"@/assets/locales/zh-Hant.json\";\nimport zh from \"@/assets/locales/zh.json\";\n\nexport const locales = {\n  en,\n  ca,\n  \"ca-ES\": caVl,\n  cs,\n  da,\n  de,\n  fr,\n  it,\n  nl,\n  pl,\n  tr,\n  vi,\n  zh,\n  he,\n  sv,\n  pirate,\n  kitty,\n  uwu,\n  minion,\n  lv,\n  th,\n  ne,\n  ar,\n  es,\n  et,\n  tok,\n  hi,\n  \"pt-BR\": ptbr,\n  \"pt-PT\": ptpt,\n  uk,\n  bg,\n  bn,\n  el,\n  fa,\n  gu,\n  id,\n  ja,\n  ko,\n  sl,\n  ta,\n  \"zh-Hant\": zhhant,\n  is,\n  ru,\n  gl,\n  pa,\n  ro,\n  fi,\n  nv,\n};\n\nexport type Locales = keyof typeof locales;\n","import countryLanguages, { LanguageObj } from \"@ladjs/country-language\";\nimport { getTag } from \"@sozialhelden/ietf-language-tags\";\nimport { iso6393To1 } from \"iso-639-3\";\n\nconst languageOrder = [\"en\", \"hi\", \"fr\", \"de\", \"nl\", \"pt\"];\n\n// mapping of language code to country code.\n// multiple mappings can exist, since languages are spoken in multiple countries.\n// This mapping purely exists to prioritize a country over another in languages where the base language code does\n// not contain a region (i.e. if the language code is zh-Hant where Hant is a script) or if the region in the language code is incorrect\n// iso639_1 -> iso3166 Alpha-2\nconst countryPriority: Record<string, string> = {\n  zh: \"cn\",\n  nv: \"us\",\n};\n\n// list of iso639_1 Alpha-2 codes used as default languages\nconst defaultLanguageCodes: string[] = [\n  \"ar-SA\",\n  \"bg-BG\",\n  \"bn-BD\",\n  \"cs-CZ\",\n  \"ca-AD\",\n  \"da-DK\",\n  \"de-DE\",\n  \"el-GR\",\n  \"en-US\",\n  \"es-ES\",\n  \"et-EE\",\n  \"fa-IR\",\n  \"fr-FR\",\n  \"gl-ES\",\n  \"gu-IN\",\n  \"he-IL\",\n  \"id-ID\",\n  \"it-IT\",\n  \"ja-JP\",\n  \"ko-KR\",\n  \"lv-LV\",\n  \"ne-NP\",\n  \"nl-NL\",\n  \"pl-PL\",\n  \"pt-BR\",\n  \"ru-RU\",\n  \"sl-SI\",\n  \"sv-SE\",\n  \"ta-LK\",\n  \"th-TH\",\n  \"tr-TR\",\n  \"vi-VN\",\n  \"zh-CN\",\n  \"nv-US\",\n];\n\nexport interface LocaleInfo {\n  name: string;\n  nativeName?: string;\n  code: string;\n  isRtl?: boolean;\n}\n\nconst extraLanguages: Record<string, LocaleInfo> = {\n  pirate: {\n    code: \"pirate\",\n    name: \"Pirate\",\n    nativeName: \"Pirate Tongue\",\n  },\n  kitty: {\n    code: \"cat\",\n    name: \"Cat\",\n    nativeName: \"Kitty Speak\",\n  },\n  uwu: {\n    code: \"uwu\",\n    name: \"Cutsie OwO\",\n    nativeName: \"UwU\",\n  },\n  minion: {\n    code: \"minion\",\n    name: \"Minion\",\n    nativeName: \"Minionese\",\n  },\n  tok: {\n    code: \"tok\",\n    name: \"Toki pona\",\n    nativeName: \"Toki pona\",\n  },\n};\n\nfunction populateLanguageCode(language: string): string {\n  if (language.includes(\"-\")) return language;\n  if (language.length !== 2) return language;\n  return (\n    defaultLanguageCodes.find((v) => v.startsWith(`${language}-`)) ?? language\n  );\n}\n\n/**\n * @param locale idk what kinda code this takes, anything in ietf format I guess\n * @returns pretty format for language, null if it no info can be found for language\n */\nexport function getPrettyLanguageNameFromLocale(locale: string): string | null {\n  const tag =\n    locale.length === 3\n      ? getTag(iso6393To1[locale] ?? locale, true)\n      : getTag(locale, true);\n  const lang = tag?.language?.Description?.[0] ?? null;\n  if (!lang) return null;\n\n  const region = tag?.region?.Description?.[0] ?? null;\n  let regionText = \"\";\n  if (region) regionText = ` (${region})`;\n\n  return `${lang}${regionText}`;\n}\n\n/**\n * Sort locale codes by occurrence, rest on alphabetical order\n * @param langCodes list language codes to sort\n * @returns sorted version of inputted list\n */\nexport function sortLangCodes(langCodes: string[]) {\n  const languagesOrder = [...languageOrder].reverse(); // Reverse is necessary, not sure why\n\n  const results = langCodes.sort((a, b) => {\n    const langOrderA = languagesOrder.findIndex(\n      (v) => a.startsWith(`${v}-`) || a === v,\n    );\n    const langOrderB = languagesOrder.findIndex(\n      (v) => b.startsWith(`${v}-`) || b === v,\n    );\n    if (langOrderA !== -1 || langOrderB !== -1) return langOrderB - langOrderA;\n\n    return a.localeCompare(b);\n  });\n\n  return results;\n}\n\n/**\n * Get country code for locale\n * @param locale input locale\n * @returns country code or null\n */\nexport function getCountryCodeForLocale(locale: string): string | null {\n  let output: LanguageObj | null = null as any as LanguageObj;\n  const tag = getTag(populateLanguageCode(locale), true);\n\n  if (!tag?.language?.Subtag) return null;\n  // this function isn't async, so its guaranteed to work like this\n  countryLanguages.getLanguage(tag.language.Subtag, (_err, lang) => {\n    if (lang) output = lang;\n  });\n\n  if (!output) return null;\n  const priority = countryPriority[output.iso639_1.toLowerCase()];\n  if (output.countries.length === 0) {\n    return priority ?? null;\n  }\n\n  if (priority) {\n    const prioritizedCountry = output.countries.find(\n      (v) => v.code_2.toLowerCase() === priority,\n    );\n    if (prioritizedCountry) return prioritizedCountry.code_2.toLowerCase();\n  }\n\n  // If the language contains a region, check that against the countries and\n  // return the region if it matches\n  const regionSubtag = tag?.region?.Subtag.toLowerCase();\n  if (regionSubtag) {\n    const regionCode = output.countries.find(\n      (c) =>\n        c.code_2.toLowerCase() === regionSubtag ||\n        c.code_3.toLowerCase() === regionSubtag,\n    );\n    if (regionCode) return regionCode.code_2.toLowerCase();\n  }\n  return output.countries[0].code_2.toLowerCase();\n}\n\n/**\n * Get information for a specific local\n * @param locale local code\n * @returns locale object\n */\nexport function getLocaleInfo(locale: string): LocaleInfo | null {\n  const realLocale = populateLanguageCode(locale);\n  const extraLang = extraLanguages[realLocale];\n  if (extraLang) return extraLang;\n\n  const tag = getTag(realLocale, true);\n  if (!tag?.language?.Subtag) return null;\n\n  let output: LanguageObj | null = null as any as LanguageObj;\n  // this function isnt async, so its garuanteed to work like this\n  countryLanguages.getLanguage(tag.language.Subtag, (_err, lang) => {\n    if (lang) output = lang;\n  });\n  if (!output) return null;\n\n  const extras = [];\n  if (tag.region?.Description) extras.push(tag.region.Description[0]);\n  if (tag.script?.Description) extras.push(tag.script.Description[0]);\n  const extraStringified = extras.map((v) => `(${v})`).join(\" \");\n\n  return {\n    code: tag.parts.langtag ?? realLocale,\n    isRtl: output.direction === \"RTL\",\n    name: output.name[0] + (extraStringified ? ` ${extraStringified}` : \"\"),\n    nativeName: output.nativeName[0] ?? undefined,\n  };\n}\n","import i18n from \"i18next\";\nimport { initReactI18next } from \"react-i18next\";\n\nimport { locales } from \"@/assets/languages\";\nimport { getLocaleInfo } from \"@/utils/language\";\n\n// Languages\nconst langCodes = Object.keys(locales);\nconst resources = Object.fromEntries(\n  Object.entries(locales).map((entry) => [entry[0], { translation: entry[1] }]),\n);\ni18n.use(initReactI18next).init({\n  fallbackLng: \"en\",\n  resources,\n  interpolation: {\n    escapeValue: false, // not needed for react as it escapes by default\n  },\n});\n\nexport const appLanguageOptions = langCodes.map((lang) => {\n  const langObj = getLocaleInfo(lang);\n  if (!langObj)\n    throw new Error(`Language with code ${lang} cannot be found in database`);\n  return langObj;\n});\n\nexport default i18n;\n","import merge from \"lodash.merge\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface SubtitleStyling {\n  /**\n   * Text color of subtitles, hex string\n   */\n  color: string;\n\n  /**\n   * size percentage, ranges between 0.01 and 2\n   */\n  size: number;\n\n  /**\n   * background opacity, ranges between 0 and 1\n   */\n  backgroundOpacity: number;\n\n  /**\n   * background blur, ranges between 0 and 1\n   */\n  backgroundBlur: number;\n\n  /**\n   * bold, boolean\n   */\n  bold: boolean;\n}\n\nexport interface SubtitleStore {\n  lastSync: {\n    lastSelectedLanguage: string | null;\n  };\n  enabled: boolean;\n  lastSelectedLanguage: string | null;\n  isOpenSubtitles: boolean;\n  styling: SubtitleStyling;\n  overrideCasing: boolean;\n  delay: number;\n  updateStyling(newStyling: Partial<SubtitleStyling>): void;\n  setLanguage(language: string | null): void;\n  setIsOpenSubtitles(isOpenSubtitles: boolean): void;\n  setCustomSubs(): void;\n  setOverrideCasing(enabled: boolean): void;\n  setDelay(delay: number): void;\n  importSubtitleLanguage(lang: string | null): void;\n  resetSubtitleSpecificSettings(): void;\n}\n\nexport const useSubtitleStore = create(\n  persist(\n    immer<SubtitleStore>((set) => ({\n      enabled: false,\n      lastSync: {\n        lastSelectedLanguage: null,\n      },\n      lastSelectedLanguage: null,\n      isOpenSubtitles: false,\n      overrideCasing: false,\n      delay: 0,\n      styling: {\n        color: \"#ffffff\",\n        backgroundOpacity: 0.5,\n        size: 1,\n        backgroundBlur: 0.5,\n        bold: false,\n      },\n      resetSubtitleSpecificSettings() {\n        set((s) => {\n          s.delay = 0;\n          s.overrideCasing = false;\n        });\n      },\n      updateStyling(newStyling) {\n        set((s) => {\n          if (newStyling.backgroundOpacity !== undefined)\n            s.styling.backgroundOpacity = Math.min(\n              1,\n              Math.max(0, newStyling.backgroundOpacity),\n            );\n          if (newStyling.backgroundBlur !== undefined)\n            s.styling.backgroundBlur = Math.min(\n              1,\n              Math.max(0, newStyling.backgroundBlur),\n            );\n          if (newStyling.color !== undefined)\n            s.styling.color = newStyling.color.toLowerCase();\n          if (newStyling.size !== undefined)\n            s.styling.size = Math.min(10, Math.max(0.01, newStyling.size));\n          if (newStyling.bold !== undefined) s.styling.bold = newStyling.bold;\n        });\n      },\n      setLanguage(lang) {\n        set((s) => {\n          s.enabled = !!lang;\n          if (lang) s.lastSelectedLanguage = lang;\n        });\n      },\n      setIsOpenSubtitles(isOpenSubtitles) {\n        set((s) => {\n          s.isOpenSubtitles = isOpenSubtitles;\n        });\n      },\n      setCustomSubs() {\n        set((s) => {\n          s.enabled = true;\n          s.lastSelectedLanguage = null;\n        });\n      },\n      setOverrideCasing(enabled) {\n        set((s) => {\n          s.overrideCasing = enabled;\n        });\n      },\n      setDelay(delay) {\n        set((s) => {\n          s.delay = Math.max(Math.min(500, delay), -500);\n        });\n      },\n      importSubtitleLanguage(lang) {\n        set((s) => {\n          s.lastSelectedLanguage = lang;\n          s.lastSync.lastSelectedLanguage = lang;\n        });\n      },\n    })),\n    {\n      name: \"__MW::subtitles\",\n      merge: (persisted, current) => merge({}, current, persisted),\n    },\n  ),\n);\n","import { useLanguageStore } from \"@/stores/language\";\nimport { useSubtitleStore } from \"@/stores/subtitles\";\n\nimport { MWSettingsData, MWSettingsDataV1 } from \"./types\";\nimport { createVersionedStore } from \"../migrations\";\n\nexport const SettingsStore = createVersionedStore<Record<never, never>>()\n  .setKey(\"mw-settings\")\n  .addVersion({\n    version: 0,\n    create(): MWSettingsDataV1 {\n      return {\n        language: \"en\",\n        captionSettings: {\n          delay: 0,\n          style: {\n            color: \"#ffffff\",\n            fontSize: 25,\n            backgroundColor: \"#00000096\",\n          },\n        },\n      };\n    },\n    migrate(data: MWSettingsDataV1): MWSettingsData {\n      return {\n        language: data.language,\n        captionSettings: {\n          language: \"none\",\n          ...data.captionSettings,\n        },\n      };\n    },\n  })\n  .addVersion({\n    version: 1,\n    migrate(old: MWSettingsData): Record<never, never> {\n      const langStore = useLanguageStore.getState();\n      const subtitleStore = useSubtitleStore.getState();\n\n      const backgroundColor = old.captionSettings.style.backgroundColor;\n      let backgroundOpacity = 0.5;\n      if (backgroundColor.length === 9) {\n        const opacitySplit = backgroundColor.slice(7); // '#' + 6 digits\n        backgroundOpacity = parseInt(opacitySplit, 16) / 255; // read as hex;\n      }\n\n      langStore.setLanguage(old.language);\n      subtitleStore.updateStyling({\n        backgroundOpacity,\n        color: old.captionSettings.style.color,\n        size: old.captionSettings.style.fontSize / 25,\n      });\n      subtitleStore.importSubtitleLanguage(\n        old.captionSettings.language === \"none\"\n          ? null\n          : old.captionSettings.language,\n      );\n\n      return {};\n    },\n  })\n  .addVersion({\n    version: 2,\n    create(): Record<never, never> {\n      return {};\n    },\n  })\n  .build();\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface VolumeStore {\n  volume: number;\n  setVolume(v: number): void;\n}\n\nexport interface EmpheralVolumeStore {\n  showVolume: boolean;\n  setShowVolume(v: boolean): void;\n}\n\nexport const useVolumeStore = create(\n  persist(\n    immer<VolumeStore>((set) => ({\n      volume: 1,\n      setVolume(v: number) {\n        set((s) => {\n          s.volume = v;\n        });\n      },\n    })),\n    {\n      name: \"__MW::volume\",\n    },\n  ),\n);\n\nexport const useEmpheralVolumeStore = create(\n  immer<EmpheralVolumeStore>((set) => ({\n    showVolume: false,\n    setShowVolume(bool: boolean) {\n      set((s) => {\n        s.showVolume = bool;\n      });\n    },\n  })),\n);\n","import { useVolumeStore } from \"@/stores/volume\";\n\nimport { createVersionedStore } from \"../migrations\";\n\ninterface VolumeStoreData {\n  volume: number;\n}\n\nexport const volumeStore = createVersionedStore<Record<never, never>>()\n  .setKey(\"mw-volume\")\n  .addVersion({\n    version: 0,\n    create() {\n      return {\n        volume: 1,\n      };\n    },\n    migrate(data: VolumeStoreData): Record<never, never> {\n      useVolumeStore.getState().setVolume(data.volume);\n      return {};\n    },\n  })\n  .addVersion({\n    version: 1,\n    create() {\n      return {};\n    },\n  })\n  .build();\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { PlayerMeta } from \"@/stores/player/slices/source\";\n\nexport interface ProgressItem {\n  watched: number;\n  duration: number;\n}\n\nexport interface ProgressSeasonItem {\n  title: string;\n  number: number;\n  id: string;\n}\n\nexport interface ProgressEpisodeItem {\n  title: string;\n  number: number;\n  id: string;\n  seasonId: string;\n  updatedAt: number;\n  progress: ProgressItem;\n}\n\nexport interface ProgressMediaItem {\n  title: string;\n  year?: number;\n  poster?: string;\n  type: \"show\" | \"movie\";\n  progress?: ProgressItem;\n  updatedAt: number;\n  seasons: Record<string, ProgressSeasonItem>;\n  episodes: Record<string, ProgressEpisodeItem>;\n}\n\nexport interface ProgressUpdateItem {\n  title?: string;\n  year?: number;\n  poster?: string;\n  type?: \"show\" | \"movie\";\n  progress?: ProgressItem;\n  tmdbId: string;\n  id: string;\n  episodeId?: string;\n  seasonId?: string;\n  episodeNumber?: number;\n  seasonNumber?: number;\n  action: \"upsert\" | \"delete\";\n}\n\nexport interface UpdateItemOptions {\n  meta: PlayerMeta;\n  progress: ProgressItem;\n}\n\nexport interface ProgressStore {\n  items: Record<string, ProgressMediaItem>;\n  updateQueue: ProgressUpdateItem[];\n  updateItem(ops: UpdateItemOptions): void;\n  removeItem(id: string): void;\n  replaceItems(items: Record<string, ProgressMediaItem>): void;\n  clear(): void;\n  clearUpdateQueue(): void;\n  removeUpdateItem(id: string): void;\n}\n\nlet updateId = 0;\n\nexport const useProgressStore = create(\n  persist(\n    immer<ProgressStore>((set) => ({\n      items: {},\n      updateQueue: [],\n      removeItem(id) {\n        set((s) => {\n          updateId += 1;\n          s.updateQueue.push({\n            id: updateId.toString(),\n            action: \"delete\",\n            tmdbId: id,\n          });\n\n          delete s.items[id];\n        });\n      },\n      replaceItems(items: Record<string, ProgressMediaItem>) {\n        set((s) => {\n          s.items = items;\n        });\n      },\n      updateItem({ meta, progress }) {\n        set((s) => {\n          // add to updateQueue\n          updateId += 1;\n          s.updateQueue.push({\n            tmdbId: meta.tmdbId,\n            title: meta.title,\n            year: meta.releaseYear,\n            poster: meta.poster,\n            type: meta.type,\n            progress: { ...progress },\n            id: updateId.toString(),\n            episodeId: meta.episode?.tmdbId,\n            seasonId: meta.season?.tmdbId,\n            seasonNumber: meta.season?.number,\n            episodeNumber: meta.episode?.number,\n            action: \"upsert\",\n          });\n\n          // add to progress store\n          if (!s.items[meta.tmdbId])\n            s.items[meta.tmdbId] = {\n              type: meta.type,\n              episodes: {},\n              seasons: {},\n              updatedAt: 0,\n              title: meta.title,\n              year: meta.releaseYear,\n              poster: meta.poster,\n            };\n          const item = s.items[meta.tmdbId];\n          item.updatedAt = Date.now();\n\n          if (meta.type === \"movie\") {\n            if (!item.progress)\n              item.progress = {\n                duration: 0,\n                watched: 0,\n              };\n            item.progress = { ...progress };\n            return;\n          }\n\n          if (!meta.episode || !meta.season) return;\n\n          if (!item.seasons[meta.season.tmdbId])\n            item.seasons[meta.season.tmdbId] = {\n              id: meta.season.tmdbId,\n              number: meta.season.number,\n              title: meta.season.title,\n            };\n\n          if (!item.episodes[meta.episode.tmdbId])\n            item.episodes[meta.episode.tmdbId] = {\n              id: meta.episode.tmdbId,\n              number: meta.episode.number,\n              title: meta.episode.title,\n              seasonId: meta.season.tmdbId,\n              updatedAt: Date.now(),\n              progress: {\n                duration: 0,\n                watched: 0,\n              },\n            };\n\n          item.episodes[meta.episode.tmdbId].progress = { ...progress };\n        });\n      },\n      clear() {\n        set((s) => {\n          s.items = {};\n        });\n      },\n      clearUpdateQueue() {\n        set((s) => {\n          s.updateQueue = [];\n        });\n      },\n      removeUpdateItem(id: string) {\n        set((s) => {\n          s.updateQueue = [...s.updateQueue.filter((v) => v.id !== id)];\n        });\n      },\n    })),\n    {\n      name: \"__MW::progress\",\n    },\n  ),\n);\n","import { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { ProgressMediaItem } from \"@/stores/progress\";\n\nimport { WatchedStoreData } from \"../types\";\n\nexport function migrateV4Videos(old: WatchedStoreData) {\n  // Convert items\n  const newItems: Record<string, ProgressMediaItem> = {};\n\n  for (const oldItem of old.items) {\n    if (oldItem.item.meta.type === MWMediaType.SERIES) {\n      // Upsert\n      if (!newItems[oldItem.item.meta.id]) {\n        newItems[oldItem.item.meta.id] = {\n          type: \"show\",\n          episodes: {},\n          seasons: {},\n          title: oldItem.item.meta.title,\n          updatedAt: oldItem.watchedAt,\n          poster: oldItem.item.meta.poster,\n          year: Number(oldItem.item.meta.year),\n        };\n      }\n\n      // Add episodes\n      if (\n        oldItem.item.series &&\n        !newItems[oldItem.item.meta.id].episodes[oldItem.item.series.episodeId]\n      ) {\n        // Find episode ID (barely ever works)\n        const episodeTitle = oldItem.item.meta.seasonData.episodes.find(\n          (ep) => ep.number === oldItem.item.series?.episode,\n        )?.title;\n\n        // Add season to season data\n        newItems[oldItem.item.meta.id].seasons[oldItem.item.series.seasonId] = {\n          id: oldItem.item.series.seasonId,\n          number: oldItem.item.series.season,\n          title:\n            oldItem.item.meta.seasons.find(\n              (s) => s.number === oldItem.item.series?.season,\n            )?.title || \"Unknown season\",\n        };\n\n        // Populate episode data\n        newItems[oldItem.item.meta.id].episodes[oldItem.item.series.episodeId] =\n          {\n            title: episodeTitle || \"Unknown\",\n            id: oldItem.item.series.episodeId,\n            number: oldItem.item.series.episode,\n            seasonId: oldItem.item.series.seasonId,\n            updatedAt: oldItem.watchedAt,\n            progress: {\n              duration: (100 / oldItem.percentage) * oldItem.progress,\n              watched: oldItem.progress,\n            },\n          };\n      }\n    } else {\n      newItems[oldItem.item.meta.id] = {\n        type: \"movie\",\n        episodes: {},\n        seasons: {},\n        title: oldItem.item.meta.title,\n        updatedAt: oldItem.watchedAt,\n        year: Number(oldItem.item.meta.year),\n        poster: oldItem.item.meta.poster,\n        progress: {\n          duration: (100 / oldItem.percentage) * oldItem.progress,\n          watched: oldItem.progress,\n        },\n      };\n    }\n  }\n\n  return newItems;\n}\n","import { useProgressStore } from \"@/stores/progress\";\n\nimport { OldData, migrateV2Videos } from \"./migrations/v2\";\nimport { migrateV3Videos } from \"./migrations/v3\";\nimport { migrateV4Videos } from \"./migrations/v4\";\nimport { WatchedStoreData } from \"./types\";\nimport { createVersionedStore } from \"../migrations\";\n\nexport const VideoProgressStore = createVersionedStore<WatchedStoreData>()\n  .setKey(\"video-progress\")\n  .addVersion({\n    version: 0,\n    migrate() {\n      return {\n        items: [], // dont migrate from version 0 to version 1, unmigratable\n      };\n    },\n  })\n  .addVersion({\n    version: 1,\n    async migrate(old: OldData) {\n      return migrateV2Videos(old);\n    },\n  })\n  .addVersion({\n    version: 2,\n    migrate(old: WatchedStoreData) {\n      return migrateV3Videos(old);\n    },\n  })\n  .addVersion({\n    version: 3,\n    migrate(old: WatchedStoreData): WatchedStoreData {\n      useProgressStore.getState().replaceItems(migrateV4Videos(old));\n\n      return {\n        items: [],\n      };\n    },\n  })\n  .addVersion({\n    version: 4,\n    create() {\n      return {\n        items: [],\n      };\n    },\n  })\n  .build();\n","import { ofetch } from \"ofetch\";\n\nexport interface SessionResponse {\n  id: string;\n  userId: string;\n  createdAt: string;\n  accessedAt: string;\n  device: string;\n  userAgent: string;\n}\nexport interface LoginResponse {\n  session: SessionResponse;\n  token: string;\n}\n\nexport function getAuthHeaders(token: string): Record<string, string> {\n  return {\n    authorization: `Bearer ${token}`,\n  };\n}\n\nexport async function accountLogin(\n  url: string,\n  id: string,\n  deviceName: string,\n): Promise<LoginResponse> {\n  return ofetch<LoginResponse>(\"/auth/login\", {\n    method: \"POST\",\n    body: {\n      id,\n      device: deviceName,\n    },\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { BookmarkResponse } from \"@/backend/accounts/user\";\nimport { AccountWithToken } from \"@/stores/auth\";\nimport { BookmarkMediaItem } from \"@/stores/bookmarks\";\n\nexport interface BookmarkMetaInput {\n  title: string;\n  year: number;\n  poster?: string;\n  type: string;\n}\n\nexport interface BookmarkInput {\n  tmdbId: string;\n  meta: BookmarkMetaInput;\n}\n\nexport function bookmarkMediaToInput(\n  tmdbId: string,\n  item: BookmarkMediaItem,\n): BookmarkInput {\n  return {\n    meta: {\n      title: item.title,\n      type: item.type,\n      poster: item.poster,\n      year: item.year ?? 0,\n    },\n    tmdbId,\n  };\n}\n\nexport async function addBookmark(\n  url: string,\n  account: AccountWithToken,\n  input: BookmarkInput,\n) {\n  return ofetch<BookmarkResponse>(\n    `/users/${account.userId}/bookmarks/${input.tmdbId}`,\n    {\n      method: \"POST\",\n      headers: getAuthHeaders(account.token),\n      baseURL: url,\n      body: input,\n    },\n  );\n}\n\nexport async function removeBookmark(\n  url: string,\n  account: AccountWithToken,\n  id: string,\n) {\n  return ofetch<{ tmdbId: string }>(\n    `/users/${account.userId}/bookmarks/${id}`,\n    {\n      method: \"DELETE\",\n      headers: getAuthHeaders(account.token),\n      baseURL: url,\n    },\n  );\n}\n","import { pbkdf2Async } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { generateMnemonic, validateMnemonic } from \"@scure/bip39\";\nimport { wordlist } from \"@scure/bip39/wordlists/english\";\nimport forge from \"node-forge\";\n\ntype Keys = {\n  privateKey: Uint8Array;\n  publicKey: Uint8Array;\n  seed: Uint8Array;\n};\n\nasync function seedFromMnemonic(mnemonic: string) {\n  return pbkdf2Async(sha256, mnemonic, \"mnemonic\", {\n    c: 2048,\n    dkLen: 32,\n  });\n}\n\nexport function verifyValidMnemonic(mnemonic: string) {\n  return validateMnemonic(mnemonic, wordlist);\n}\n\nexport async function keysFromMnemonic(mnemonic: string): Promise<Keys> {\n  const seed = await seedFromMnemonic(mnemonic);\n\n  const { privateKey, publicKey } = forge.pki.ed25519.generateKeyPair({\n    seed,\n  });\n\n  return {\n    privateKey,\n    publicKey,\n    seed,\n  };\n}\n\nexport function genMnemonic(): string {\n  return generateMnemonic(wordlist);\n}\n\nexport async function signCode(\n  code: string,\n  privateKey: Uint8Array,\n): Promise<Uint8Array> {\n  return forge.pki.ed25519.sign({\n    encoding: \"utf8\",\n    message: code,\n    privateKey,\n  });\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  return forge.util.encode64(String.fromCodePoint(...bytes));\n}\n\nexport function bytesToBase64Url(bytes: Uint8Array): string {\n  return bytesToBase64(bytes)\n    .replace(/\\//g, \"_\")\n    .replace(/\\+/g, \"-\")\n    .replace(/=+$/, \"\");\n}\n\nexport async function signChallenge(keys: Keys, challengeCode: string) {\n  const signature = await signCode(challengeCode, keys.privateKey);\n  return bytesToBase64Url(signature);\n}\n\nexport function base64ToBuffer(data: string) {\n  return forge.util.binary.base64.decode(data);\n}\n\nexport function base64ToStringBuffer(data: string) {\n  return forge.util.createBuffer(base64ToBuffer(data));\n}\n\nexport function stringBufferToBase64(buffer: forge.util.ByteStringBuffer) {\n  return forge.util.encode64(buffer.getBytes());\n}\n\nexport async function encryptData(data: string, secret: Uint8Array) {\n  if (secret.byteLength !== 32)\n    throw new Error(\"Secret must be at least 256-bit\");\n\n  const iv = await new Promise<string>((resolve, reject) => {\n    forge.random.getBytes(16, (err, bytes) => {\n      if (err) reject(err);\n      resolve(bytes);\n    });\n  });\n\n  const cipher = forge.cipher.createCipher(\n    \"AES-GCM\",\n    forge.util.createBuffer(secret),\n  );\n  cipher.start({\n    iv,\n    tagLength: 128,\n  });\n  cipher.update(forge.util.createBuffer(data, \"utf8\"));\n  cipher.finish();\n\n  const encryptedData = cipher.output;\n  const tag = cipher.mode.tag;\n\n  return `${forge.util.encode64(iv)}.${stringBufferToBase64(\n    encryptedData,\n  )}.${stringBufferToBase64(tag)}` as const;\n}\n\nexport function decryptData(data: string, secret: Uint8Array) {\n  if (secret.byteLength !== 32) throw new Error(\"Secret must be 256-bit\");\n\n  const [iv, encryptedData, tag] = data.split(\".\");\n\n  const decipher = forge.cipher.createDecipher(\n    \"AES-GCM\",\n    forge.util.createBuffer(secret),\n  );\n  decipher.start({\n    iv: base64ToStringBuffer(iv),\n    tag: base64ToStringBuffer(tag),\n    tagLength: 128,\n  });\n  decipher.update(base64ToStringBuffer(encryptedData));\n  const pass = decipher.finish();\n\n  if (!pass) throw new Error(\"Error decrypting data\");\n\n  return decipher.output.toString();\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\n\nimport { BookmarkInput } from \"./bookmarks\";\nimport { ProgressInput } from \"./progress\";\n\nexport function importProgress(\n  url: string,\n  account: AccountWithToken,\n  progressItems: ProgressInput[],\n) {\n  return ofetch<void>(`/users/${account.userId}/progress/import`, {\n    method: \"PUT\",\n    body: progressItems,\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n\nexport function importBookmarks(\n  url: string,\n  account: AccountWithToken,\n  bookmarks: BookmarkInput[],\n) {\n  return ofetch<void>(`/users/${account.userId}/bookmarks`, {\n    method: \"PUT\",\n    body: bookmarks,\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { SessionResponse } from \"@/backend/accounts/auth\";\n\nexport interface ChallengeTokenResponse {\n  challenge: string;\n}\n\nexport async function getLoginChallengeToken(\n  url: string,\n  publicKey: string,\n): Promise<ChallengeTokenResponse> {\n  return ofetch<ChallengeTokenResponse>(\"/auth/login/start\", {\n    method: \"POST\",\n    body: {\n      publicKey,\n    },\n    baseURL: url,\n  });\n}\n\nexport interface LoginResponse {\n  session: SessionResponse;\n  token: string;\n}\n\nexport interface LoginInput {\n  publicKey: string;\n  challenge: {\n    code: string;\n    signature: string;\n  };\n  device: string;\n}\n\nexport async function loginAccount(\n  url: string,\n  data: LoginInput,\n): Promise<LoginResponse> {\n  return ofetch<LoginResponse>(\"/auth/login/complete\", {\n    method: \"POST\",\n    body: {\n      namespace: \"movie-web\",\n      ...data,\n    },\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { ProgressResponse } from \"@/backend/accounts/user\";\nimport { AccountWithToken } from \"@/stores/auth\";\nimport { ProgressMediaItem, ProgressUpdateItem } from \"@/stores/progress\";\n\nexport interface ProgressInput {\n  meta?: {\n    title: string;\n    year: number;\n    poster?: string;\n    type: string;\n  };\n  tmdbId: string;\n  watched: number;\n  duration: number;\n  seasonId?: string;\n  episodeId?: string;\n  seasonNumber?: number;\n  episodeNumber?: number;\n  updatedAt?: string;\n}\n\nexport function progressUpdateItemToInput(\n  item: ProgressUpdateItem,\n): ProgressInput {\n  return {\n    duration: item.progress?.duration ?? 0,\n    watched: item.progress?.watched ?? 0,\n    tmdbId: item.tmdbId,\n    meta: {\n      title: item.title ?? \"\",\n      type: item.type ?? \"\",\n      year: item.year ?? NaN,\n      poster: item.poster,\n    },\n    episodeId: item.episodeId,\n    seasonId: item.seasonId,\n    episodeNumber: item.episodeNumber,\n    seasonNumber: item.seasonNumber,\n  };\n}\n\nexport function progressMediaItemToInputs(\n  tmdbId: string,\n  item: ProgressMediaItem,\n): ProgressInput[] {\n  if (item.type === \"show\") {\n    return Object.entries(item.episodes).flatMap(([_, episode]) => ({\n      duration: item.progress?.duration ?? episode.progress.duration,\n      watched: item.progress?.watched ?? episode.progress.watched,\n      tmdbId,\n      meta: {\n        title: item.title ?? \"\",\n        type: item.type ?? \"\",\n        year: item.year ?? NaN,\n        poster: item.poster,\n      },\n      episodeId: episode.id,\n      seasonId: episode.seasonId,\n      episodeNumber: episode.number,\n      seasonNumber: item.seasons[episode.seasonId].number,\n      updatedAt: new Date(episode.updatedAt).toISOString(),\n    }));\n  }\n  return [\n    {\n      duration: item.progress?.duration ?? 0,\n      watched: item.progress?.watched ?? 0,\n      tmdbId,\n      updatedAt: new Date(item.updatedAt).toISOString(),\n      meta: {\n        title: item.title ?? \"\",\n        type: item.type ?? \"\",\n        year: item.year ?? NaN,\n        poster: item.poster,\n      },\n    },\n  ];\n}\n\nexport async function setProgress(\n  url: string,\n  account: AccountWithToken,\n  input: ProgressInput,\n) {\n  return ofetch<ProgressResponse>(\n    `/users/${account.userId}/progress/${input.tmdbId}`,\n    {\n      method: \"PUT\",\n      headers: getAuthHeaders(account.token),\n      baseURL: url,\n      body: input,\n    },\n  );\n}\n\nexport async function removeProgress(\n  url: string,\n  account: AccountWithToken,\n  id: string,\n  episodeId?: string,\n  seasonId?: string,\n) {\n  await ofetch(`/users/${account.userId}/progress/${id}`, {\n    method: \"DELETE\",\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n    body: {\n      episodeId,\n      seasonId,\n    },\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { SessionResponse } from \"@/backend/accounts/auth\";\nimport { UserResponse } from \"@/backend/accounts/user\";\n\nexport interface ChallengeTokenResponse {\n  challenge: string;\n}\n\nexport async function getRegisterChallengeToken(\n  url: string,\n  captchaToken?: string,\n): Promise<ChallengeTokenResponse> {\n  return ofetch<ChallengeTokenResponse>(\"/auth/register/start\", {\n    method: \"POST\",\n    body: {\n      captchaToken,\n    },\n    baseURL: url,\n  });\n}\n\nexport interface RegisterResponse {\n  user: UserResponse;\n  session: SessionResponse;\n  token: string;\n}\n\nexport interface RegisterInput {\n  publicKey: string;\n  challenge: {\n    code: string;\n    signature: string;\n  };\n  device: string;\n  profile: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport async function registerAccount(\n  url: string,\n  data: RegisterInput,\n): Promise<RegisterResponse> {\n  return ofetch<RegisterResponse>(\"/auth/register/complete\", {\n    method: \"POST\",\n    body: {\n      namespace: \"movie-web\",\n      ...data,\n    },\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\n\nexport interface SessionResponse {\n  id: string;\n  userId: string;\n  createdAt: string;\n  accessedAt: string;\n  device: string;\n  userAgent: string;\n}\n\nexport interface SessionUpdate {\n  deviceName: string;\n}\n\nexport async function getSessions(url: string, account: AccountWithToken) {\n  return ofetch<SessionResponse[]>(`/users/${account.userId}/sessions`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n\nexport async function updateSession(\n  url: string,\n  account: AccountWithToken,\n  update: SessionUpdate,\n) {\n  return ofetch<SessionResponse[]>(`/sessions/${account.sessionId}`, {\n    method: \"PATCH\",\n    headers: getAuthHeaders(account.token),\n    body: update,\n    baseURL: url,\n  });\n}\n\nexport async function removeSession(\n  url: string,\n  token: string,\n  sessionId: string,\n) {\n  return ofetch<SessionResponse[]>(`/sessions/${sessionId}`, {\n    method: \"DELETE\",\n    headers: getAuthHeaders(token),\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\n\nexport interface SettingsInput {\n  applicationLanguage?: string;\n  applicationTheme?: string | null;\n  defaultSubtitleLanguage?: string;\n  proxyUrls?: string[] | null;\n}\n\nexport interface SettingsResponse {\n  applicationTheme?: string | null;\n  applicationLanguage?: string | null;\n  defaultSubtitleLanguage?: string | null;\n  proxyUrls?: string[] | null;\n}\n\nexport function updateSettings(\n  url: string,\n  account: AccountWithToken,\n  settings: SettingsInput,\n) {\n  return ofetch<SettingsResponse>(`/users/${account.userId}/settings`, {\n    method: \"PUT\",\n    body: settings,\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n\nexport function getSettings(url: string, account: AccountWithToken) {\n  return ofetch<SettingsResponse>(`/users/${account.userId}/settings`, {\n    method: \"GET\",\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { SessionResponse, getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\nimport { BookmarkMediaItem } from \"@/stores/bookmarks\";\nimport { ProgressMediaItem } from \"@/stores/progress\";\n\nexport interface UserResponse {\n  id: string;\n  namespace: string;\n  name: string;\n  roles: string[];\n  createdAt: string;\n  profile: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport interface UserEdit {\n  profile?: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport interface BookmarkResponse {\n  tmdbId: string;\n  meta: {\n    title: string;\n    year: number;\n    poster?: string;\n    type: \"show\" | \"movie\";\n  };\n  updatedAt: string;\n}\n\nexport interface ProgressResponse {\n  tmdbId: string;\n  season: {\n    id?: string;\n    number?: number;\n  };\n  episode: {\n    id?: string;\n    number?: number;\n  };\n  meta: {\n    title: string;\n    year: number;\n    poster?: string;\n    type: \"show\" | \"movie\";\n  };\n  duration: string;\n  watched: string;\n  updatedAt: string;\n}\n\nexport function bookmarkResponsesToEntries(responses: BookmarkResponse[]) {\n  const entries = responses.map((bookmark) => {\n    const item: BookmarkMediaItem = {\n      ...bookmark.meta,\n      updatedAt: new Date(bookmark.updatedAt).getTime(),\n    };\n    return [bookmark.tmdbId, item] as const;\n  });\n\n  return Object.fromEntries(entries);\n}\n\nexport function progressResponsesToEntries(responses: ProgressResponse[]) {\n  const items: Record<string, ProgressMediaItem> = {};\n\n  responses.forEach((v) => {\n    if (!items[v.tmdbId]) {\n      items[v.tmdbId] = {\n        title: v.meta.title,\n        poster: v.meta.poster,\n        type: v.meta.type,\n        updatedAt: new Date(v.updatedAt).getTime(),\n        episodes: {},\n        seasons: {},\n        year: v.meta.year,\n      };\n    }\n\n    const item = items[v.tmdbId];\n\n    // Since each watched episode is a single array entry but with the same tmdbId, the root item updatedAt will only have the first episode's timestamp (which is not the newest).\n    // Here, we are setting it explicitly so the updatedAt always has the highest updatedAt from the episodes.\n    if (new Date(v.updatedAt).getTime() > item.updatedAt) {\n      item.updatedAt = new Date(v.updatedAt).getTime();\n    }\n\n    if (item.type === \"movie\") {\n      item.progress = {\n        duration: Number(v.duration),\n        watched: Number(v.watched),\n      };\n    }\n\n    if (item.type === \"show\" && v.season.id && v.episode.id) {\n      item.seasons[v.season.id] = {\n        id: v.season.id,\n        number: v.season.number ?? 0,\n        title: \"\",\n      };\n      item.episodes[v.episode.id] = {\n        id: v.episode.id,\n        number: v.episode.number ?? 0,\n        title: \"\",\n        progress: {\n          duration: Number(v.duration),\n          watched: Number(v.watched),\n        },\n        seasonId: v.season.id,\n        updatedAt: new Date(v.updatedAt).getTime(),\n      };\n    }\n  });\n\n  return items;\n}\n\nexport async function getUser(\n  url: string,\n  token: string,\n): Promise<{ user: UserResponse; session: SessionResponse }> {\n  return ofetch<{ user: UserResponse; session: SessionResponse }>(\n    \"/users/@me\",\n    {\n      headers: getAuthHeaders(token),\n      baseURL: url,\n    },\n  );\n}\n\nexport async function editUser(\n  url: string,\n  account: AccountWithToken,\n  object: UserEdit,\n): Promise<{ user: UserResponse; session: SessionResponse }> {\n  return ofetch<{ user: UserResponse; session: SessionResponse }>(\n    `/users/${account.userId}`,\n    {\n      method: \"PATCH\",\n      headers: getAuthHeaders(account.token),\n      body: object,\n      baseURL: url,\n    },\n  );\n}\n\nexport async function deleteUser(\n  url: string,\n  account: AccountWithToken,\n): Promise<UserResponse> {\n  return ofetch<UserResponse>(`/users/${account.userId}`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n\nexport async function getBookmarks(url: string, account: AccountWithToken) {\n  return ofetch<BookmarkResponse[]>(`/users/${account.userId}/bookmarks`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n\nexport async function getProgress(url: string, account: AccountWithToken) {\n  return ofetch<ProgressResponse[]>(`/users/${account.userId}/progress`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n","import { useCallback } from \"react\";\n\nimport { LoginResponse, SessionResponse } from \"@/backend/accounts/auth\";\nimport { SettingsResponse } from \"@/backend/accounts/settings\";\nimport {\n  BookmarkResponse,\n  ProgressResponse,\n  UserResponse,\n  bookmarkResponsesToEntries,\n  progressResponsesToEntries,\n} from \"@/backend/accounts/user\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { useBookmarkStore } from \"@/stores/bookmarks\";\nimport { useLanguageStore } from \"@/stores/language\";\nimport { useProgressStore } from \"@/stores/progress\";\nimport { useSubtitleStore } from \"@/stores/subtitles\";\nimport { useThemeStore } from \"@/stores/theme\";\n\nexport function useAuthData() {\n  const loggedIn = !!useAuthStore((s) => s.account);\n  const setAccount = useAuthStore((s) => s.setAccount);\n  const removeAccount = useAuthStore((s) => s.removeAccount);\n  const setProxySet = useAuthStore((s) => s.setProxySet);\n  const clearBookmarks = useBookmarkStore((s) => s.clear);\n  const clearProgress = useProgressStore((s) => s.clear);\n  const setTheme = useThemeStore((s) => s.setTheme);\n  const setAppLanguage = useLanguageStore((s) => s.setLanguage);\n  const importSubtitleLanguage = useSubtitleStore(\n    (s) => s.importSubtitleLanguage,\n  );\n\n  const replaceBookmarks = useBookmarkStore((s) => s.replaceBookmarks);\n  const replaceItems = useProgressStore((s) => s.replaceItems);\n\n  const login = useCallback(\n    async (\n      loginResponse: LoginResponse,\n      user: UserResponse,\n      session: SessionResponse,\n      seed: string,\n    ) => {\n      const account = {\n        token: loginResponse.token,\n        userId: user.id,\n        sessionId: loginResponse.session.id,\n        deviceName: session.device,\n        profile: user.profile,\n        seed,\n      };\n      setAccount(account);\n      return account;\n    },\n    [setAccount],\n  );\n\n  const logout = useCallback(async () => {\n    removeAccount();\n    clearBookmarks();\n    clearProgress();\n  }, [removeAccount, clearBookmarks, clearProgress]);\n\n  const syncData = useCallback(\n    async (\n      _user: UserResponse,\n      _session: SessionResponse,\n      progress: ProgressResponse[],\n      bookmarks: BookmarkResponse[],\n      settings: SettingsResponse,\n    ) => {\n      replaceBookmarks(bookmarkResponsesToEntries(bookmarks));\n      replaceItems(progressResponsesToEntries(progress));\n\n      if (settings.applicationLanguage) {\n        setAppLanguage(settings.applicationLanguage);\n      }\n\n      if (settings.defaultSubtitleLanguage) {\n        importSubtitleLanguage(settings.defaultSubtitleLanguage);\n      }\n\n      if (settings.applicationTheme) {\n        setTheme(settings.applicationTheme);\n      }\n\n      if (settings.proxyUrls) {\n        setProxySet(settings.proxyUrls);\n      }\n    },\n    [\n      replaceBookmarks,\n      replaceItems,\n      setAppLanguage,\n      importSubtitleLanguage,\n      setTheme,\n      setProxySet,\n    ],\n  );\n\n  return {\n    loggedIn,\n    login,\n    logout,\n    syncData,\n  };\n}\n","import { conf } from \"@/setup/config\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nexport function useBackendUrl(): string | null {\n  const backendUrl = useAuthStore((s) => s.backendUrl);\n  return backendUrl ?? conf().BACKEND_URL;\n}\n","import { useCallback } from \"react\";\n\nimport { SessionResponse } from \"@/backend/accounts/auth\";\nimport { bookmarkMediaToInput } from \"@/backend/accounts/bookmarks\";\nimport {\n  bytesToBase64,\n  bytesToBase64Url,\n  encryptData,\n  keysFromMnemonic,\n  signChallenge,\n} from \"@/backend/accounts/crypto\";\nimport { importBookmarks, importProgress } from \"@/backend/accounts/import\";\nimport { getLoginChallengeToken, loginAccount } from \"@/backend/accounts/login\";\nimport { progressMediaItemToInputs } from \"@/backend/accounts/progress\";\nimport {\n  getRegisterChallengeToken,\n  registerAccount,\n} from \"@/backend/accounts/register\";\nimport { removeSession } from \"@/backend/accounts/sessions\";\nimport { getSettings } from \"@/backend/accounts/settings\";\nimport {\n  UserResponse,\n  getBookmarks,\n  getProgress,\n  getUser,\n} from \"@/backend/accounts/user\";\nimport { useAuthData } from \"@/hooks/auth/useAuthData\";\nimport { useBackendUrl } from \"@/hooks/auth/useBackendUrl\";\nimport { AccountWithToken, useAuthStore } from \"@/stores/auth\";\nimport { BookmarkMediaItem } from \"@/stores/bookmarks\";\nimport { ProgressMediaItem } from \"@/stores/progress\";\n\nexport interface RegistrationData {\n  recaptchaToken?: string;\n  mnemonic: string;\n  userData: {\n    device: string;\n    profile: {\n      colorA: string;\n      colorB: string;\n      icon: string;\n    };\n  };\n}\n\nexport interface LoginData {\n  mnemonic: string;\n  userData: {\n    device: string;\n  };\n}\n\nexport function useAuth() {\n  const currentAccount = useAuthStore((s) => s.account);\n  const profile = useAuthStore((s) => s.account?.profile);\n  const loggedIn = !!useAuthStore((s) => s.account);\n  const backendUrl = useBackendUrl();\n  const {\n    logout: userDataLogout,\n    login: userDataLogin,\n    syncData,\n  } = useAuthData();\n\n  const login = useCallback(\n    async (loginData: LoginData) => {\n      if (!backendUrl) return;\n      const keys = await keysFromMnemonic(loginData.mnemonic);\n      const publicKeyBase64Url = bytesToBase64Url(keys.publicKey);\n      const { challenge } = await getLoginChallengeToken(\n        backendUrl,\n        publicKeyBase64Url,\n      );\n      const signature = await signChallenge(keys, challenge);\n      const loginResult = await loginAccount(backendUrl, {\n        challenge: {\n          code: challenge,\n          signature,\n        },\n        publicKey: publicKeyBase64Url,\n        device: await encryptData(loginData.userData.device, keys.seed),\n      });\n\n      const user = await getUser(backendUrl, loginResult.token);\n      const seedBase64 = bytesToBase64(keys.seed);\n      return userDataLogin(loginResult, user.user, user.session, seedBase64);\n    },\n    [userDataLogin, backendUrl],\n  );\n\n  const logout = useCallback(async () => {\n    if (!currentAccount || !backendUrl) return;\n    try {\n      await removeSession(\n        backendUrl,\n        currentAccount.token,\n        currentAccount.sessionId,\n      );\n    } catch {\n      // we dont care about failing to delete session\n    }\n    await userDataLogout();\n  }, [userDataLogout, backendUrl, currentAccount]);\n\n  const register = useCallback(\n    async (registerData: RegistrationData) => {\n      if (!backendUrl) return;\n      const { challenge } = await getRegisterChallengeToken(\n        backendUrl,\n        registerData.recaptchaToken,\n      );\n      const keys = await keysFromMnemonic(registerData.mnemonic);\n      const signature = await signChallenge(keys, challenge);\n      const registerResult = await registerAccount(backendUrl, {\n        challenge: {\n          code: challenge,\n          signature,\n        },\n        publicKey: bytesToBase64Url(keys.publicKey),\n        device: await encryptData(registerData.userData.device, keys.seed),\n        profile: registerData.userData.profile,\n      });\n\n      return userDataLogin(\n        registerResult,\n        registerResult.user,\n        registerResult.session,\n        bytesToBase64(keys.seed),\n      );\n    },\n    [backendUrl, userDataLogin],\n  );\n\n  const importData = useCallback(\n    async (\n      account: AccountWithToken,\n      progressItems: Record<string, ProgressMediaItem>,\n      bookmarks: Record<string, BookmarkMediaItem>,\n    ) => {\n      if (!backendUrl) return;\n      if (\n        Object.keys(progressItems).length === 0 &&\n        Object.keys(bookmarks).length === 0\n      ) {\n        return;\n      }\n\n      const progressInputs = Object.entries(progressItems).flatMap(\n        ([tmdbId, item]) => progressMediaItemToInputs(tmdbId, item),\n      );\n\n      const bookmarkInputs = Object.entries(bookmarks).map(([tmdbId, item]) =>\n        bookmarkMediaToInput(tmdbId, item),\n      );\n\n      await Promise.all([\n        importProgress(backendUrl, account, progressInputs),\n        importBookmarks(backendUrl, account, bookmarkInputs),\n      ]);\n    },\n    [backendUrl],\n  );\n\n  const restore = useCallback(\n    async (account: AccountWithToken) => {\n      if (!backendUrl) return;\n      let user: { user: UserResponse; session: SessionResponse };\n      try {\n        user = await getUser(backendUrl, account.token);\n      } catch (err) {\n        const anyError: any = err;\n        if (\n          anyError?.response?.status === 401 ||\n          anyError?.response?.status === 403 ||\n          anyError?.response?.status === 400\n        ) {\n          await logout();\n          return;\n        }\n        console.error(err);\n        throw err;\n      }\n\n      const [bookmarks, progress, settings] = await Promise.all([\n        getBookmarks(backendUrl, account),\n        getProgress(backendUrl, account),\n        getSettings(backendUrl, account),\n      ]);\n\n      syncData(user.user, user.session, progress, bookmarks, settings);\n    },\n    [backendUrl, syncData, logout],\n  );\n\n  return {\n    loggedIn,\n    profile,\n    login,\n    logout,\n    register,\n    restore,\n    importData,\n  };\n}\n","import { useRef } from \"react\";\nimport { useAsync, useInterval } from \"react-use\";\n\nimport { useAuth } from \"@/hooks/auth/useAuth\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nconst AUTH_CHECK_INTERVAL = 12 * 60 * 60 * 1000;\n\nexport function useAuthRestore() {\n  const { account } = useAuthStore();\n  const { restore } = useAuth();\n  const hasRestored = useRef(false);\n\n  useInterval(() => {\n    if (account) restore(account);\n  }, AUTH_CHECK_INTERVAL);\n\n  const result = useAsync(async () => {\n    if (hasRestored.current || !account) return;\n    await restore(account).finally(() => {\n      hasRestored.current = true;\n    });\n  }, []); // no deps because we don't want to it ever rerun after the first time\n\n  return result;\n}\n","import { useCallback, useMemo } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nexport function useQueryParams() {\n  const loc = useLocation();\n\n  const queryParams = useMemo(() => {\n    const obj: Record<string, string> = Object.fromEntries(\n      new URLSearchParams(loc.search).entries(),\n    );\n\n    return obj;\n  }, [loc.search]);\n\n  return queryParams;\n}\n\nexport function useQueryParam(\n  param: string,\n): [string | null, (a: string | null) => void] {\n  const params = useQueryParams();\n  const location = useLocation();\n  const navigate = useNavigate();\n  const currentValue = params[param] ?? null;\n\n  const set = useCallback(\n    (value: string | null) => {\n      const parsed = new URLSearchParams(location.search);\n      if (value) parsed.set(param, value);\n      else parsed.delete(param);\n      navigate({\n        search: parsed.toString(),\n      });\n    },\n    [param, location.search, navigate],\n  );\n\n  return [currentValue, set];\n}\n","import { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface OverlayTransition {\n  from: string;\n  to: string;\n}\n\nexport interface OverlayRoute {\n  id: string;\n  height: number;\n  width: number;\n}\n\nexport interface ActiveAnchorPoint {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\ninterface OverlayStore {\n  transition: null | OverlayTransition;\n  routes: Record<string, OverlayRoute>;\n  anchorPoint: ActiveAnchorPoint | null;\n  setTransition(newTrans: OverlayTransition | null): void;\n  registerRoute(route: OverlayRoute): void;\n  setAnchorPoint(point: ActiveAnchorPoint | null): void;\n}\n\nexport const useOverlayStore = create(\n  immer<OverlayStore>((set) => ({\n    transition: null,\n    routes: {},\n    anchorPoint: null,\n    setTransition(newTrans) {\n      set((s) => {\n        s.transition = newTrans;\n      });\n    },\n    registerRoute(route) {\n      set((s) => {\n        s.routes[route.id] = route;\n      });\n    },\n    setAnchorPoint(point) {\n      set((s) => {\n        s.anchorPoint = point;\n      });\n    },\n  })),\n);\n","import { useCallback, useEffect, useMemo } from \"react\";\n\nimport { useQueryParam } from \"@/hooks/useQueryParams\";\nimport { useOverlayStore } from \"@/stores/overlay/store\";\n\nfunction splitPath(path: string, prefix?: string): string[] {\n  const parts = [prefix ?? \"\", ...path.split(\"/\")];\n  return parts.filter((v) => v.length > 0);\n}\n\nfunction joinPath(path: string[]): string {\n  return `/${path.join(\"/\")}`;\n}\n\nexport function useRouterAnchorUpdate(id: string) {\n  const [route] = useQueryParam(\"r\");\n  const setAnchorPoint = useOverlayStore((s) => s.setAnchorPoint);\n  const routerActive = useMemo(\n    () => !!route && route.startsWith(`/${id}`),\n    [route, id],\n  );\n\n  const update = useCallback(() => {\n    if (!routerActive) return;\n    const anchor = document.getElementById(`__overlayRouter::${id}`);\n    if (anchor) {\n      const rect = anchor.getBoundingClientRect();\n      setAnchorPoint({\n        h: rect.height,\n        w: rect.width,\n        x: rect.x,\n        y: rect.y,\n      });\n    }\n  }, [routerActive, setAnchorPoint, id]);\n\n  useEffect(() => {\n    update();\n  }, [routerActive, update]);\n\n  useEffect(() => {\n    function resizeEvent() {\n      update();\n    }\n    window.addEventListener(\"resize\", resizeEvent);\n    return () => {\n      window.removeEventListener(\"resize\", resizeEvent);\n    };\n  }, [update]);\n}\n\nexport function useInternalOverlayRouter(id: string) {\n  const [route, setRoute] = useQueryParam(\"r\");\n  const transition = useOverlayStore((s) => s.transition);\n  const setTransition = useOverlayStore((s) => s.setTransition);\n  const routerActive = !!route && route.startsWith(`/${id}`);\n\n  function makePath(path: string) {\n    return joinPath(splitPath(path, id));\n  }\n\n  function navigate(path: string) {\n    const oldRoute = route;\n    const newRoute = joinPath(splitPath(path, id));\n    setTransition({\n      from: oldRoute ?? \"/\",\n      to: newRoute,\n    });\n    setRoute(newRoute);\n  }\n\n  function showBackwardsTransition(path: string) {\n    if (!transition) return \"none\";\n    const current = joinPath(splitPath(path, id));\n\n    if (current === transition.to && transition.from.startsWith(transition.to))\n      return \"yes\";\n    if (\n      current === transition.from &&\n      transition.to.startsWith(transition.from)\n    )\n      return \"yes\";\n    return \"no\";\n  }\n\n  function isCurrentPage(path: string) {\n    return routerActive && route === joinPath(splitPath(path, id));\n  }\n\n  function isOverlayActive() {\n    return routerActive;\n  }\n\n  const close = useCallback(\n    (preventRouteClear?: boolean) => {\n      if (route && !preventRouteClear) setRoute(null);\n      setTransition(null);\n    },\n    [setRoute, route, setTransition],\n  );\n\n  const open = useCallback(\n    (defaultRoute = \"/\") => {\n      setTransition(null);\n      setRoute(joinPath(splitPath(defaultRoute, id)));\n    },\n    [id, setRoute, setTransition],\n  );\n\n  const activeRoute = routerActive\n    ? joinPath(splitPath(route.slice(`/${id}`.length)))\n    : \"/\";\n\n  return {\n    activeRoute,\n    showBackwardsTransition,\n    isCurrentPage,\n    isOverlayActive,\n    navigate,\n    close,\n    open,\n    makePath,\n    currentRoute: route,\n  };\n}\n\nexport function useOverlayRouter(id: string) {\n  const router = useInternalOverlayRouter(id);\n  return {\n    id,\n    route: router.activeRoute,\n    isRouterActive: router.isOverlayActive(),\n    open: router.open,\n    close: router.close,\n    navigate: router.navigate,\n  };\n}\n","import { useEffect, useRef, useState } from \"react\";\n\nexport function useIsMobile(horizontal?: boolean) {\n  const [isMobile, setIsMobile] = useState(false);\n  const isMobileCurrent = useRef<boolean | null>(false);\n\n  useEffect(() => {\n    function onResize() {\n      const value = horizontal\n        ? window.innerHeight < 600\n        : window.innerWidth < 1024;\n      const isChanged = isMobileCurrent.current !== value;\n      if (!isChanged) return;\n\n      isMobileCurrent.current = value;\n      setIsMobile(value);\n    }\n\n    onResize();\n    window.addEventListener(\"resize\", onResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [horizontal]);\n\n  return {\n    isMobile,\n  };\n}\n","import { useEffect } from \"react\";\nimport { useMeasure } from \"react-use\";\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\ninterface BannerInstance {\n  id: string;\n  height: number;\n}\n\ninterface BannerStore {\n  banners: BannerInstance[];\n  isOnline: boolean;\n  isTurnstile: boolean;\n  location: string | null;\n  ignoredBannerIds: string[];\n  updateHeight(id: string, height: number): void;\n  showBanner(id: string): void;\n  hideBanner(id: string, force?: boolean): void;\n  setLocation(loc: string | null): void;\n  updateOnline(isOnline: boolean): void;\n  updateTurnstile(isTurnstile: boolean): void;\n}\n\nexport const useBannerStore = create(\n  immer<BannerStore>((set) => ({\n    banners: [],\n    isOnline: true,\n    isTurnstile: false,\n    location: null,\n    ignoredBannerIds: [],\n    updateOnline(isOnline) {\n      set((s) => {\n        s.isOnline = isOnline;\n      });\n    },\n    updateTurnstile(isTurnstile) {\n      set((s) => {\n        s.isTurnstile = isTurnstile;\n      });\n    },\n    setLocation(loc) {\n      set((s) => {\n        s.location = loc;\n      });\n    },\n    showBanner(id) {\n      set((s) => {\n        if (s.banners.find((v) => v.id === id)) return;\n        if (s.ignoredBannerIds.includes(id)) return;\n        s.banners.push({\n          id,\n          height: 0,\n        });\n      });\n    },\n    hideBanner(id, force = false) {\n      set((s) => {\n        if (force) s.ignoredBannerIds.push(id);\n        s.banners = s.banners.filter((v) => v.id !== id);\n      });\n    },\n    updateHeight(id, height) {\n      set((s) => {\n        const found = s.banners.find((v) => v.id === id);\n        if (found) found.height = height;\n      });\n    },\n  })),\n);\n\nexport function useBannerSize(location?: string) {\n  const loc = location ?? null;\n  const banners = useBannerStore((s) => s.banners);\n  const currentLocation = useBannerStore((s) => s.location);\n\n  const size = banners.reduce((a, v) => a + v.height, 0);\n  if (loc !== currentLocation) return 0;\n  return size;\n}\n\nexport function useRegisterBanner<T extends Element>(id: string) {\n  const [ref, { height }] = useMeasure<T>();\n  const updateHeight = useBannerStore((s) => s.updateHeight);\n  const showBanner = useBannerStore((s) => s.showBanner);\n  const hideBanner = useBannerStore((s) => s.hideBanner);\n\n  useEffect(() => {\n    showBanner(id);\n    return () => {\n      hideBanner(id);\n    };\n  }, [showBanner, hideBanner, id]);\n\n  useEffect(() => {\n    updateHeight(id, height);\n  }, [height, id, updateHeight]);\n\n  return [ref];\n}\n","import { useEffect, useRef } from \"react\";\n\nimport { useBannerStore } from \"@/stores/banner\";\n\nexport function useOnlineListener() {\n  const updateOnline = useBannerStore((s) => s.updateOnline);\n  const ref = useRef<boolean>(true);\n\n  useEffect(() => {\n    let counter = 0;\n\n    let abort: null | AbortController = null;\n    const interval = setInterval(() => {\n      // if online try once every 10 iterations intead of every iteration\n      counter += 1;\n      if (ref.current) {\n        if (counter < 10) return;\n      }\n      counter = 0;\n\n      if (abort) abort.abort();\n      abort = new AbortController();\n      const signal = abort.signal;\n      fetch(\"/ping.txt\", { signal })\n        .then(() => {\n          updateOnline(true);\n          ref.current = true;\n        })\n        .catch((err) => {\n          if (err.name === \"AbortError\") return;\n          updateOnline(false);\n          ref.current = false;\n        });\n    }, 5000);\n\n    return () => {\n      clearInterval(interval);\n      if (abort) abort.abort();\n    };\n  }, [updateOnline]);\n}\n","import { ofetch } from \"ofetch\";\n\nexport interface MetaResponse {\n  version: string;\n  name: string;\n  description?: string;\n  hasCaptcha: boolean;\n  captchaClientKey?: string;\n}\n\nexport async function getBackendMeta(url: string): Promise<MetaResponse> {\n  return ofetch<MetaResponse>(\"/meta\", {\n    baseURL: url,\n  });\n}\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface CastingSlice {\n  casting: {\n    instance: cast.framework.CastContext | null;\n    player: cast.framework.RemotePlayer | null;\n    controller: cast.framework.RemotePlayerController | null;\n    setInstance(instance: cast.framework.CastContext): void;\n    setPlayer(player: cast.framework.RemotePlayer): void;\n    setController(controller: cast.framework.RemotePlayerController): void;\n    setIsCasting(isCasting: boolean): void;\n    clear(): void;\n  };\n}\n\nexport const createCastingSlice: MakeSlice<CastingSlice> = (set) => ({\n  casting: {\n    instance: null,\n    player: null,\n    controller: null,\n    setInstance(instance) {\n      set((s) => {\n        s.casting.instance = instance;\n      });\n    },\n    setPlayer(player) {\n      set((s) => {\n        s.casting.player = player;\n      });\n    },\n    setController(controller) {\n      set((s) => {\n        s.casting.controller = controller;\n      });\n    },\n    setIsCasting(isCasting) {\n      set((s) => {\n        s.interface.isCasting = isCasting;\n      });\n    },\n    clear() {\n      set((s) => {\n        s.casting.instance = null;\n      });\n    },\n  },\n});\n","import { Qualities, Stream } from \"@movie-web/providers\";\n\nimport { QualityStore } from \"@/stores/quality\";\n\nexport type SourceQuality = Qualities;\n\nexport type StreamType = \"hls\" | \"mp4\";\n\nexport type SourceFileStream = {\n  type: \"mp4\";\n  url: string;\n};\n\nexport type LoadableSource = {\n  type: StreamType;\n  url: string;\n  headers?: Stream[\"headers\"];\n  preferredHeaders?: Stream[\"preferredHeaders\"];\n};\n\nexport type SourceSliceSource =\n  | {\n      type: \"file\";\n      qualities: Partial<Record<SourceQuality, SourceFileStream>>;\n      headers?: Stream[\"headers\"];\n      preferredHeaders?: Stream[\"preferredHeaders\"];\n    }\n  | {\n      type: \"hls\";\n      url: string;\n      headers?: Stream[\"headers\"];\n      preferredHeaders?: Stream[\"preferredHeaders\"];\n    };\n\nconst qualitySorting: Record<SourceQuality, number> = {\n  unknown: 0,\n  \"360\": 10,\n  \"480\": 20,\n  \"720\": 30,\n  \"1080\": 40,\n  \"4k\": 35, // 4k has lower priority, you need faster internet for it\n};\nconst sortedQualities: SourceQuality[] = Object.entries(qualitySorting)\n  .sort((a, b) => b[1] - a[1])\n  .map<SourceQuality>((v) => v[0] as SourceQuality);\n\nexport function getPreferredQuality(\n  availableQualites: SourceQuality[],\n  qualityPreferences: QualityStore[\"quality\"],\n) {\n  if (\n    qualityPreferences.automaticQuality ||\n    qualityPreferences.lastChosenQuality === null ||\n    qualityPreferences.lastChosenQuality === \"unknown\"\n  )\n    return sortedQualities.find((v) => availableQualites.includes(v));\n\n  // get preferred quality - not automatic or unknown\n  const chosenQualityIndex = sortedQualities.indexOf(\n    qualityPreferences.lastChosenQuality,\n  );\n  let nearestChoseQuality: undefined | SourceQuality;\n\n  // check chosen quality or lower\n  for (let i = chosenQualityIndex; i < sortedQualities.length; i += 1) {\n    if (availableQualites.includes(sortedQualities[i])) {\n      nearestChoseQuality = sortedQualities[i];\n      break;\n    }\n  }\n  if (nearestChoseQuality) return nearestChoseQuality;\n\n  // chosen quality or lower doesn't exist, try higher\n  for (let i = chosenQualityIndex; i >= 0; i -= 1) {\n    if (availableQualites.includes(sortedQualities[i])) {\n      nearestChoseQuality = sortedQualities[i];\n      break;\n    }\n  }\n  return nearestChoseQuality;\n}\n\nexport function selectQuality(\n  source: SourceSliceSource,\n  qualityPreferences: QualityStore[\"quality\"],\n): {\n  stream: LoadableSource;\n  quality: null | SourceQuality;\n} {\n  if (source.type === \"hls\")\n    return {\n      stream: source,\n      quality: null,\n    };\n  if (source.type === \"file\") {\n    const availableQualities = Object.entries(source.qualities)\n      .filter((entry) => (entry[1].url.length ?? 0) > 0)\n      .map((entry) => entry[0]) as SourceQuality[];\n    const quality = getPreferredQuality(availableQualities, qualityPreferences);\n    if (quality) {\n      const stream = source.qualities[quality];\n      if (stream) {\n        return { stream, quality };\n      }\n    }\n  }\n  throw new Error(\"couldn't select quality\");\n}\n\nconst qualityNameMap: Record<SourceQuality, string> = {\n  \"4k\": \"4K\",\n  \"1080\": \"1080p\",\n  \"360\": \"360p\",\n  \"480\": \"480p\",\n  \"720\": \"720p\",\n  unknown: \"unknown\",\n};\n\nexport const allQualities = Object.keys(qualityNameMap) as SourceQuality[];\n\nexport function qualityToString(quality: SourceQuality): string {\n  return qualityNameMap[quality];\n}\n","import merge from \"lodash.merge\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { SourceQuality } from \"@/stores/player/utils/qualities\";\n\nexport interface QualityStore {\n  quality: {\n    lastChosenQuality: SourceQuality | null;\n    automaticQuality: boolean;\n  };\n  setLastChosenQuality(v: SourceQuality | null): void;\n  setAutomaticQuality(v: boolean): void;\n}\n\nexport const useQualityStore = create(\n  persist(\n    immer<QualityStore>((set) => ({\n      quality: {\n        automaticQuality: true,\n        lastChosenQuality: null,\n      },\n      setLastChosenQuality(v) {\n        set((s) => {\n          s.quality.lastChosenQuality = v;\n        });\n      },\n      setAutomaticQuality(v) {\n        set((s) => {\n          s.quality.automaticQuality = v;\n        });\n      },\n    })),\n    {\n      name: \"__MW::quality\",\n      merge: (persisted, current) => merge({}, current, persisted),\n    },\n  ),\n);\n","import { ScrapeMedia } from \"@movie-web/providers\";\n\nimport { MakeSlice } from \"@/stores/player/slices/types\";\nimport {\n  SourceQuality,\n  SourceSliceSource,\n  selectQuality,\n} from \"@/stores/player/utils/qualities\";\nimport { useQualityStore } from \"@/stores/quality\";\nimport { ValuesOf } from \"@/utils/typeguard\";\n\nexport const playerStatus = {\n  IDLE: \"idle\",\n  SCRAPING: \"scraping\",\n  PLAYING: \"playing\",\n  SCRAPE_NOT_FOUND: \"scrapeNotFound\",\n  PLAYBACK_ERROR: \"playbackError\",\n} as const;\n\nexport type PlayerStatus = ValuesOf<typeof playerStatus>;\n\nexport interface PlayerMetaEpisode {\n  number: number;\n  tmdbId: string;\n  title: string;\n}\n\nexport interface PlayerMeta {\n  type: \"movie\" | \"show\";\n  title: string;\n  tmdbId: string;\n  imdbId?: string;\n  releaseYear: number;\n  poster?: string;\n  episodes?: PlayerMetaEpisode[];\n  episode?: PlayerMetaEpisode;\n  season?: {\n    number: number;\n    tmdbId: string;\n    title: string;\n  };\n}\n\nexport interface Caption {\n  id: string;\n  language: string;\n  url?: string;\n  srtData: string;\n}\n\nexport interface CaptionListItem {\n  id: string;\n  language: string;\n  url: string;\n  needsProxy: boolean;\n  hls?: boolean;\n  opensubtitles?: boolean;\n}\n\nexport interface AudioTrack {\n  id: string;\n  label: string;\n  language: string;\n}\n\nexport interface SourceSlice {\n  status: PlayerStatus;\n  source: SourceSliceSource | null;\n  sourceId: string | null;\n  qualities: SourceQuality[];\n  audioTracks: AudioTrack[];\n  currentQuality: SourceQuality | null;\n  currentAudioTrack: AudioTrack | null;\n  captionList: CaptionListItem[];\n  caption: {\n    selected: Caption | null;\n    asTrack: boolean;\n  };\n  meta: PlayerMeta | null;\n  setStatus(status: PlayerStatus): void;\n  setSource(\n    stream: SourceSliceSource,\n    captions: CaptionListItem[],\n    startAt: number,\n  ): void;\n  switchQuality(quality: SourceQuality): void;\n  setMeta(meta: PlayerMeta, status?: PlayerStatus): void;\n  setCaption(caption: Caption | null): void;\n  setSourceId(id: string | null): void;\n  enableAutomaticQuality(): void;\n  redisplaySource(startAt: number): void;\n}\n\nexport function metaToScrapeMedia(meta: PlayerMeta): ScrapeMedia {\n  if (meta.type === \"show\") {\n    if (!meta.episode || !meta.season) throw new Error(\"missing show data\");\n    return {\n      title: meta.title,\n      releaseYear: meta.releaseYear,\n      tmdbId: meta.tmdbId,\n      type: \"show\",\n      imdbId: meta.imdbId,\n      episode: meta.episode,\n      season: meta.season,\n    };\n  }\n\n  return {\n    title: meta.title,\n    releaseYear: meta.releaseYear,\n    tmdbId: meta.tmdbId,\n    type: \"movie\",\n    imdbId: meta.imdbId,\n  };\n}\n\nexport const createSourceSlice: MakeSlice<SourceSlice> = (set, get) => ({\n  source: null,\n  sourceId: null,\n  qualities: [],\n  audioTracks: [],\n  captionList: [],\n  currentQuality: null,\n  currentAudioTrack: null,\n  status: playerStatus.IDLE,\n  meta: null,\n  caption: {\n    selected: null,\n    asTrack: false,\n  },\n  setSourceId(id) {\n    set((s) => {\n      s.status = playerStatus.PLAYING;\n      s.sourceId = id;\n    });\n  },\n  setStatus(status: PlayerStatus) {\n    set((s) => {\n      s.status = status;\n    });\n  },\n  setMeta(meta, newStatus) {\n    set((s) => {\n      s.meta = meta;\n      s.interface.hideNextEpisodeBtn = false;\n      if (newStatus) s.status = newStatus;\n    });\n  },\n  setCaption(caption) {\n    const store = get();\n    store.display?.setCaption(caption);\n    set((s) => {\n      s.caption.selected = caption;\n    });\n  },\n  setSource(\n    stream: SourceSliceSource,\n    captions: CaptionListItem[],\n    startAt: number,\n  ) {\n    let qualities: string[] = [];\n    if (stream.type === \"file\") qualities = Object.keys(stream.qualities);\n    const qualityPreferences = useQualityStore.getState();\n    const loadableStream = selectQuality(stream, qualityPreferences.quality);\n\n    set((s) => {\n      s.source = stream;\n      s.qualities = qualities as SourceQuality[];\n      s.currentQuality = loadableStream.quality;\n      s.captionList = captions;\n      s.interface.error = undefined;\n      s.status = playerStatus.PLAYING;\n      s.audioTracks = [];\n      s.currentAudioTrack = null;\n    });\n    const store = get();\n    store.redisplaySource(startAt);\n  },\n  redisplaySource(startAt: number) {\n    const store = get();\n    const quality = store.currentQuality;\n    if (!store.source) return;\n    const qualityPreferences = useQualityStore.getState();\n    const loadableStream = selectQuality(store.source, {\n      automaticQuality: qualityPreferences.quality.automaticQuality,\n      lastChosenQuality: quality,\n    });\n    set((s) => {\n      s.interface.error = undefined;\n      s.status = playerStatus.PLAYING;\n    });\n    store.display?.load({\n      source: loadableStream.stream,\n      startAt,\n      automaticQuality: qualityPreferences.quality.automaticQuality,\n      preferredQuality: qualityPreferences.quality.lastChosenQuality,\n    });\n  },\n  switchQuality(quality) {\n    const store = get();\n    if (!store.source) return;\n    if (store.source.type === \"file\") {\n      const selectedQuality = store.source.qualities[quality];\n      if (!selectedQuality) return;\n      set((s) => {\n        s.currentQuality = quality;\n        s.status = playerStatus.PLAYING;\n        s.interface.error = undefined;\n      });\n      store.display?.load({\n        source: selectedQuality,\n        startAt: store.progress.time,\n        automaticQuality: false,\n        preferredQuality: quality,\n      });\n    } else if (store.source.type === \"hls\") {\n      store.display?.changeQuality(false, quality);\n    }\n  },\n  enableAutomaticQuality() {\n    const store = get();\n    store.display?.changeQuality(true, null);\n  },\n});\n","import { DisplayInterface } from \"@/components/player/display/displayInterface\";\nimport { playerStatus } from \"@/stores/player/slices/source\";\nimport { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface DisplaySlice {\n  display: DisplayInterface | null;\n  setDisplay(display: DisplayInterface | null): void;\n  reset(): void;\n}\n\nexport const createDisplaySlice: MakeSlice<DisplaySlice> = (set, get) => ({\n  display: null,\n  setDisplay(newDisplay: DisplayInterface | null) {\n    const display = get().display;\n    if (display) display.destroy();\n\n    if (!newDisplay) {\n      set((s) => {\n        s.display = null;\n      });\n      return;\n    }\n\n    // make display events update the state\n    newDisplay.on(\"pause\", () =>\n      set((s) => {\n        s.mediaPlaying.isPaused = true;\n        s.mediaPlaying.isPlaying = false;\n      }),\n    );\n    newDisplay.on(\"play\", () =>\n      set((s) => {\n        s.mediaPlaying.hasPlayedOnce = true;\n        s.mediaPlaying.isPaused = false;\n        s.mediaPlaying.isPlaying = true;\n      }),\n    );\n    newDisplay.on(\"fullscreen\", (isFullscreen) =>\n      set((s) => {\n        s.interface.isFullscreen = isFullscreen;\n      }),\n    );\n    newDisplay.on(\"time\", (time) =>\n      set((s) => {\n        s.progress.time = time;\n      }),\n    );\n    newDisplay.on(\"volumechange\", (vol) =>\n      set((s) => {\n        s.mediaPlaying.volume = vol;\n      }),\n    );\n    newDisplay.on(\"duration\", (duration) =>\n      set((s) => {\n        s.progress.duration = duration;\n      }),\n    );\n    newDisplay.on(\"buffered\", (buffered) =>\n      set((s) => {\n        s.progress.buffered = buffered;\n      }),\n    );\n    newDisplay.on(\"loading\", (isLoading) =>\n      set((s) => {\n        s.mediaPlaying.isLoading = isLoading;\n      }),\n    );\n    newDisplay.on(\"qualities\", (qualities) => {\n      set((s) => {\n        s.qualities = qualities;\n      });\n    });\n    newDisplay.on(\"changedquality\", (quality) => {\n      set((s) => {\n        s.currentQuality = quality;\n      });\n    });\n    newDisplay.on(\"audiotracks\", (audioTracks) => {\n      set((s) => {\n        s.audioTracks = audioTracks;\n      });\n    });\n    newDisplay.on(\"changedaudiotrack\", (audioTrack) => {\n      set((s) => {\n        s.currentAudioTrack = audioTrack;\n      });\n    });\n    newDisplay.on(\"needstrack\", (needsTrack) => {\n      set((s) => {\n        s.caption.asTrack = needsTrack;\n      });\n    });\n    newDisplay.on(\"canairplay\", (canAirplay) => {\n      set((s) => {\n        s.interface.canAirplay = canAirplay;\n      });\n    });\n    newDisplay.on(\"playbackrate\", (rate) => {\n      set((s) => {\n        s.mediaPlaying.playbackRate = rate;\n      });\n    });\n    newDisplay.on(\"error\", (err) => {\n      set((s) => {\n        s.status = playerStatus.PLAYBACK_ERROR;\n        s.interface.error = err;\n      });\n    });\n\n    set((s) => {\n      s.display = newDisplay;\n    });\n  },\n  reset() {\n    get().display?.load({\n      source: null,\n      startAt: 0,\n      automaticQuality: false,\n      preferredQuality: null,\n    });\n    set((s) => {\n      s.status = playerStatus.IDLE;\n      s.meta = null;\n      s.thumbnails.images = [];\n      s.progress.time = 0;\n      s.progress.duration = 0;\n    });\n  },\n});\n","import { DisplayError } from \"@/components/player/display/displayInterface\";\nimport { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport enum VideoPlayerTimeFormat {\n  REGULAR = 0,\n  REMAINING = 1,\n}\n\nexport enum PlayerHoverState {\n  NOT_HOVERING = \"not_hovering\",\n  MOUSE_HOVER = \"mouse_hover\",\n  MOBILE_TAPPED = \"mobile_tapped\",\n}\n\nexport interface InterfaceSlice {\n  interface: {\n    isFullscreen: boolean;\n    isSeeking: boolean;\n    lastVolume: number;\n    hasOpenOverlay: boolean;\n    hovering: PlayerHoverState;\n    lastHoveringState: PlayerHoverState;\n    canAirplay: boolean;\n    isCasting: boolean;\n    hideNextEpisodeBtn: boolean;\n    shouldStartFromBeginning: boolean;\n    error?: DisplayError;\n\n    volumeChangedWithKeybind: boolean; // has the volume recently been adjusted with the up/down arrows recently?\n    volumeChangedWithKeybindDebounce: NodeJS.Timeout | null; // debounce for the duration of the \"volume changed thingamajig\"\n\n    leftControlHovering: boolean; // is the cursor hovered over the left side of player controls\n    isHoveringControls: boolean; // is the cursor hovered over any controls?\n    timeFormat: VideoPlayerTimeFormat; // Time format of the video player\n  };\n  updateInterfaceHovering(newState: PlayerHoverState): void;\n  setSeeking(seeking: boolean): void;\n  setTimeFormat(format: VideoPlayerTimeFormat): void;\n  setHoveringLeftControls(state: boolean): void;\n  setHoveringAnyControls(state: boolean): void;\n  setHasOpenOverlay(state: boolean): void;\n  setLastVolume(state: number): void;\n  hideNextEpisodeButton(): void;\n  setShouldStartFromBeginning(val: boolean): void;\n}\n\nexport const createInterfaceSlice: MakeSlice<InterfaceSlice> = (set, get) => ({\n  interface: {\n    isCasting: false,\n    hasOpenOverlay: false,\n    isFullscreen: false,\n    isSeeking: false,\n    lastVolume: 0,\n    leftControlHovering: false,\n    isHoveringControls: false,\n    hovering: PlayerHoverState.NOT_HOVERING,\n    lastHoveringState: PlayerHoverState.NOT_HOVERING,\n    volumeChangedWithKeybind: false,\n    volumeChangedWithKeybindDebounce: null,\n    timeFormat: VideoPlayerTimeFormat.REGULAR,\n    canAirplay: false,\n    hideNextEpisodeBtn: false,\n    shouldStartFromBeginning: false,\n  },\n\n  setShouldStartFromBeginning(val) {\n    set((s) => {\n      s.interface.shouldStartFromBeginning = val;\n    });\n  },\n  setLastVolume(state) {\n    set((s) => {\n      s.interface.lastVolume = state;\n    });\n  },\n  setHasOpenOverlay(state) {\n    set((s) => {\n      s.interface.hasOpenOverlay = state;\n    });\n  },\n  setTimeFormat(format) {\n    set((s) => {\n      s.interface.timeFormat = format;\n    });\n  },\n  updateInterfaceHovering(newState: PlayerHoverState) {\n    set((s) => {\n      if (newState !== PlayerHoverState.NOT_HOVERING)\n        s.interface.lastHoveringState = newState;\n      s.interface.hovering = newState;\n    });\n  },\n  setSeeking(seeking) {\n    const display = get().display;\n    display?.setSeeking(seeking);\n    set((s) => {\n      s.interface.isSeeking = seeking;\n    });\n  },\n  setHoveringLeftControls(state) {\n    set((s) => {\n      s.interface.leftControlHovering = state;\n    });\n  },\n  setHoveringAnyControls(state) {\n    set((s) => {\n      s.interface.isHoveringControls = state;\n    });\n  },\n  hideNextEpisodeButton() {\n    set((s) => {\n      s.interface.hideNextEpisodeBtn = true;\n    });\n  },\n});\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface PlayingSlice {\n  mediaPlaying: {\n    isPlaying: boolean;\n    isPaused: boolean;\n    isSeeking: boolean; // seeking with progress bar\n    isDragSeeking: boolean; // is seeking for our custom progress bar\n    isLoading: boolean; // buffering or not\n    hasPlayedOnce: boolean; // has the video played at all?\n    volume: number;\n    playbackRate: number;\n  };\n  play(): void;\n  pause(): void;\n}\n\nexport const createPlayingSlice: MakeSlice<PlayingSlice> = (set) => ({\n  mediaPlaying: {\n    isPlaying: false,\n    isPaused: true,\n    isLoading: false,\n    isSeeking: false,\n    isDragSeeking: false,\n    hasPlayedOnce: false,\n    volume: 1,\n    playbackRate: 1,\n  },\n  play() {\n    set((state) => {\n      state.mediaPlaying.isPlaying = true;\n      state.mediaPlaying.isPaused = false;\n    });\n  },\n  pause() {\n    set((state) => {\n      state.mediaPlaying.isPlaying = false;\n      state.mediaPlaying.isPaused = false;\n    });\n  },\n});\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface ProgressSlice {\n  progress: {\n    time: number; // current time of video\n    duration: number; // length of video\n    buffered: number; // how much is buffered\n    draggingTime: number; // when dragging, time thats at the cursor\n  };\n  setDraggingTime(draggingTime: number): void;\n}\n\nexport const createProgressSlice: MakeSlice<ProgressSlice> = (set) => ({\n  progress: {\n    time: 0,\n    duration: 0,\n    buffered: 0,\n    draggingTime: 0,\n  },\n  setDraggingTime(draggingTime: number) {\n    set((s) => {\n      s.progress.draggingTime = draggingTime;\n    });\n  },\n});\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface ThumbnailImage {\n  at: number;\n  data: string;\n}\n\nexport interface ThumbnailSlice {\n  thumbnails: {\n    images: ThumbnailImage[];\n    addImage(img: ThumbnailImage): void;\n    resetImages(): void;\n  };\n}\n\nexport interface ThumbnailImagePosition {\n  index: number;\n  image: ThumbnailImage;\n}\n\n/**\n * get nearest image at the timestamp provided\n * @param images images, must be sorted\n */\nexport function nearestImageAt(\n  images: ThumbnailImage[],\n  at: number,\n): ThumbnailImagePosition | null {\n  // no images, early return\n  if (images.length === 0) return null;\n\n  const indexPastTimestamp = images.findIndex((v) => v.at > at);\n\n  // no image found past timestamp, so last image must be closest\n  if (indexPastTimestamp === -1)\n    return {\n      index: images.length - 1,\n      image: images[images.length - 1],\n    };\n\n  const imagePastTimestamp = images[indexPastTimestamp];\n\n  // if past timestamp is first image, just return that image\n  if (indexPastTimestamp === 0)\n    return {\n      index: indexPastTimestamp,\n      image: imagePastTimestamp,\n    };\n\n  //             distance before             distance past\n  //                    |                          |\n  //  [before] --------------------- [at] --------------------- [past]\n  const imageBeforeTimestamp = images[indexPastTimestamp - 1];\n  const distanceBefore = at - imageBeforeTimestamp.at;\n  const distancePast = imagePastTimestamp.at - at;\n\n  // if distance of before timestamp is smaller than the distance past\n  // before is closer, return that\n  //  [before] --X-------------- [past]\n  if (distanceBefore < distancePast)\n    return {\n      index: indexPastTimestamp - 1,\n      image: imageBeforeTimestamp,\n    };\n\n  // must be closer to past here, return past\n  //  [before] --------------X-- [past]\n  return {\n    index: indexPastTimestamp,\n    image: imagePastTimestamp,\n  };\n}\n\nexport const createThumbnailSlice: MakeSlice<ThumbnailSlice> = (set, get) => ({\n  thumbnails: {\n    images: [],\n    resetImages() {\n      set((s) => {\n        s.thumbnails.images = [];\n      });\n    },\n    addImage(img) {\n      const store = get();\n      const exactOrPastImageIndex = store.thumbnails.images.findIndex(\n        (v) => v.at >= img.at,\n      );\n\n      // not found past or exact, so just append to the end\n      if (exactOrPastImageIndex === -1) {\n        set((s) => {\n          s.thumbnails.images.push(img);\n          s.thumbnails.images = [...s.thumbnails.images];\n        });\n        return;\n      }\n\n      const exactOrPastImage = store.thumbnails.images[exactOrPastImageIndex];\n\n      // found exact, replace data\n      if (exactOrPastImage.at === img.at) {\n        set((s) => {\n          s.thumbnails.images[exactOrPastImageIndex] = img;\n          s.thumbnails.images = [...s.thumbnails.images];\n        });\n        return;\n      }\n\n      // found one past, insert right before it\n      set((s) => {\n        s.thumbnails.images.splice(exactOrPastImageIndex, 0, img);\n        s.thumbnails.images = [...s.thumbnails.images];\n      });\n    },\n  },\n});\n","import { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { createCastingSlice } from \"@/stores/player/slices/casting\";\nimport { createDisplaySlice } from \"@/stores/player/slices/display\";\nimport { createInterfaceSlice } from \"@/stores/player/slices/interface\";\nimport { createPlayingSlice } from \"@/stores/player/slices/playing\";\nimport { createProgressSlice } from \"@/stores/player/slices/progress\";\nimport { createSourceSlice } from \"@/stores/player/slices/source\";\nimport { createThumbnailSlice } from \"@/stores/player/slices/thumbnails\";\nimport { AllSlices } from \"@/stores/player/slices/types\";\n\nexport const usePlayerStore = create(\n  immer<AllSlices>((...a) => ({\n    ...createInterfaceSlice(...a),\n    ...createProgressSlice(...a),\n    ...createPlayingSlice(...a),\n    ...createSourceSlice(...a),\n    ...createDisplaySlice(...a),\n    ...createCastingSlice(...a),\n    ...createThumbnailSlice(...a),\n  })),\n);\n","import { RunOutput } from \"@movie-web/providers\";\nimport DOMPurify from \"dompurify\";\nimport { convert, detect, parse } from \"subsrt-ts\";\nimport { ContentCaption } from \"subsrt-ts/dist/types/handler\";\n\nimport { CaptionListItem } from \"@/stores/player/slices/source\";\n\nexport type CaptionCueType = ContentCaption;\nexport const sanitize = DOMPurify.sanitize;\n\nexport function captionIsVisible(\n  start: number,\n  end: number,\n  delay: number,\n  currentTime: number,\n) {\n  const delayedStart = start / 1000 + delay;\n  const delayedEnd = end / 1000 + delay;\n  return (\n    Math.max(0, delayedStart) <= currentTime &&\n    Math.max(0, delayedEnd) >= currentTime\n  );\n}\n\nexport function makeQueId(index: number, start: number, end: number): string {\n  return `${index}-${start}-${end}`;\n}\n\nexport function convertSubtitlesToVtt(text: string): string {\n  const textTrimmed = text.trim();\n  if (textTrimmed === \"\") {\n    throw new Error(\"Given text is empty\");\n  }\n  const vtt = convert(textTrimmed, \"vtt\");\n  if (detect(vtt) === \"\") {\n    throw new Error(\"Invalid subtitle format\");\n  }\n  return vtt;\n}\n\nexport function convertSubtitlesToSrt(text: string): string {\n  const textTrimmed = text.trim();\n  if (textTrimmed === \"\") {\n    throw new Error(\"Given text is empty\");\n  }\n  const srt = convert(textTrimmed, \"srt\");\n  if (detect(srt) === \"\") {\n    throw new Error(\"Invalid subtitle format\");\n  }\n  return srt;\n}\n\nexport function filterDuplicateCaptionCues(cues: ContentCaption[]) {\n  return cues.reduce((acc: ContentCaption[], cap: ContentCaption) => {\n    const lastCap = acc[acc.length - 1];\n    const isSameAsLast =\n      lastCap?.start === cap.start &&\n      lastCap?.end === cap.end &&\n      lastCap?.content === cap.content;\n    if (lastCap === undefined || !isSameAsLast) {\n      acc.push(cap);\n    }\n    return acc;\n  }, []);\n}\n\nexport function parseVttSubtitles(vtt: string) {\n  return parse(vtt).filter((cue) => cue.type === \"caption\") as CaptionCueType[];\n}\n\nexport function parseSubtitles(\n  text: string,\n  _language?: string,\n): CaptionCueType[] {\n  const vtt = convertSubtitlesToVtt(text);\n  return parseVttSubtitles(vtt);\n}\n\nfunction stringToBase64(input: string): string {\n  return btoa(String.fromCodePoint(...new TextEncoder().encode(input)));\n}\n\nexport function convertSubtitlesToSrtDataurl(text: string): string {\n  return `data:application/x-subrip;base64,${stringToBase64(\n    convertSubtitlesToSrt(text),\n  )}`;\n}\n\nexport function convertSubtitlesToObjectUrl(text: string): string {\n  return URL.createObjectURL(\n    new Blob([convertSubtitlesToVtt(text)], {\n      type: \"text/vtt\",\n    }),\n  );\n}\n\nexport function convertProviderCaption(\n  captions: RunOutput[\"stream\"][\"captions\"],\n): CaptionListItem[] {\n  return captions.map((v) => ({\n    id: v.id,\n    language: v.language,\n    url: v.url,\n    needsProxy: v.hasCorsRestrictions,\n    opensubtitles: v.opensubtitles,\n  }));\n}\n","import { list } from \"subsrt-ts\";\n\nimport { proxiedFetch } from \"@/backend/helpers/fetch\";\nimport { convertSubtitlesToSrt } from \"@/components/player/utils/captions\";\nimport { CaptionListItem } from \"@/stores/player/slices/source\";\nimport { SimpleCache } from \"@/utils/cache\";\n\nimport {\n  isExtensionActiveCached,\n  sendExtensionRequest,\n} from \"../extension/messaging\";\n\nexport const subtitleTypeList = list().map((type) => `.${type}`);\nconst downloadCache = new SimpleCache<string, string>();\ndownloadCache.setCompare((a, b) => a === b);\nconst expirySeconds = 24 * 60 * 60;\n\n/**\n * Always returns SRT\n */\nexport async function downloadCaption(\n  caption: CaptionListItem,\n): Promise<string> {\n  const cached = downloadCache.get(caption.url);\n  if (cached) return cached;\n\n  let data: string | undefined;\n  if (caption.needsProxy) {\n    if (isExtensionActiveCached()) {\n      const extensionResponse = await sendExtensionRequest({\n        url: caption.url,\n        method: \"GET\",\n      });\n      if (\n        !extensionResponse?.success ||\n        typeof extensionResponse.response.body !== \"string\"\n      ) {\n        throw new Error(\"failed to get caption data from extension\");\n      }\n\n      data = extensionResponse.response.body;\n    } else {\n      data = await proxiedFetch<string>(caption.url, { responseType: \"text\" });\n    }\n  } else {\n    data = await fetch(caption.url).then((v) => v.text());\n  }\n  if (!data) throw new Error(\"failed to get caption data\");\n\n  const output = convertSubtitlesToSrt(data);\n  downloadCache.set(caption.url, output, expirySeconds);\n  return output;\n}\n\n/**\n * Downloads the WebVTT content. No different than a simple\n * get request with a cache.\n */\nexport async function downloadWebVTT(url: string): Promise<string> {\n  const cached = downloadCache.get(url);\n  if (cached) return cached;\n\n  const data = await fetch(url).then((v) => v.text());\n  return data;\n}\n","import { useCallback, useMemo } from \"react\";\nimport subsrt from \"subsrt-ts\";\n\nimport { downloadCaption, downloadWebVTT } from \"@/backend/helpers/subs\";\nimport { Caption } from \"@/stores/player/slices/source\";\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { useSubtitleStore } from \"@/stores/subtitles\";\n\nimport {\n  filterDuplicateCaptionCues,\n  parseVttSubtitles,\n} from \"../utils/captions\";\n\nexport function useCaptions() {\n  const setLanguage = useSubtitleStore((s) => s.setLanguage);\n  const enabled = useSubtitleStore((s) => s.enabled);\n  const resetSubtitleSpecificSettings = useSubtitleStore(\n    (s) => s.resetSubtitleSpecificSettings,\n  );\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const lastSelectedLanguage = useSubtitleStore((s) => s.lastSelectedLanguage);\n  const setIsOpenSubtitles = useSubtitleStore((s) => s.setIsOpenSubtitles);\n\n  const captionList = usePlayerStore((s) => s.captionList);\n  const getHlsCaptionList = usePlayerStore((s) => s.display?.getCaptionList);\n\n  const getSubtitleTracks = usePlayerStore((s) => s.display?.getSubtitleTracks);\n  const setSubtitlePreference = usePlayerStore(\n    (s) => s.display?.setSubtitlePreference,\n  );\n\n  const captions = useMemo(\n    () =>\n      captionList.length !== 0 ? captionList : (getHlsCaptionList?.() ?? []),\n    [captionList, getHlsCaptionList],\n  );\n\n  const selectCaptionById = useCallback(\n    async (captionId: string) => {\n      const caption = captions.find((v) => v.id === captionId);\n      if (!caption) return;\n\n      const captionToSet: Caption = {\n        id: caption.id,\n        language: caption.language,\n        url: caption.url,\n        srtData: \"\",\n      };\n\n      if (!caption.hls) {\n        const srtData = await downloadCaption(caption);\n        captionToSet.srtData = srtData;\n      } else {\n        // request a language change to hls, so it can load the subtitles\n        await setSubtitlePreference?.(caption.language);\n        const track = getSubtitleTracks?.().find(\n          (t) => t.id.toString() === caption.id && t.details !== undefined,\n        );\n        if (!track) return;\n\n        const fragments =\n          track.details?.fragments?.filter(\n            (frag) => frag !== null && frag.url !== null,\n          ) ?? [];\n\n        const vttCaptions = (\n          await Promise.all(\n            fragments.map(async (frag) => {\n              const vtt = await downloadWebVTT(frag.url);\n              return parseVttSubtitles(vtt);\n            }),\n          )\n        ).flat();\n\n        const filtered = filterDuplicateCaptionCues(vttCaptions);\n\n        const srtData = subsrt.build(filtered, { format: \"srt\" });\n        captionToSet.srtData = srtData;\n      }\n\n      setIsOpenSubtitles(!!caption.opensubtitles);\n      setCaption(captionToSet);\n      resetSubtitleSpecificSettings();\n      setLanguage(caption.language);\n    },\n    [\n      setIsOpenSubtitles,\n      setLanguage,\n      captions,\n      setCaption,\n      resetSubtitleSpecificSettings,\n      getSubtitleTracks,\n      setSubtitlePreference,\n    ],\n  );\n\n  const selectLanguage = useCallback(\n    async (language: string) => {\n      const caption = captions.find((v) => v.language === language);\n      if (!caption) return;\n      return selectCaptionById(caption.id);\n    },\n    [captions, selectCaptionById],\n  );\n\n  const disable = useCallback(async () => {\n    setIsOpenSubtitles(false);\n    setCaption(null);\n    setLanguage(null);\n  }, [setCaption, setLanguage, setIsOpenSubtitles]);\n\n  const selectLastUsedLanguage = useCallback(async () => {\n    const language = lastSelectedLanguage ?? \"en\";\n    await selectLanguage(language);\n    return true;\n  }, [lastSelectedLanguage, selectLanguage]);\n\n  const toggleLastUsed = useCallback(async () => {\n    if (enabled) disable();\n    else await selectLastUsedLanguage();\n  }, [selectLastUsedLanguage, disable, enabled]);\n\n  const selectLastUsedLanguageIfEnabled = useCallback(async () => {\n    if (enabled) await selectLastUsedLanguage();\n  }, [selectLastUsedLanguage, enabled]);\n\n  return {\n    selectLanguage,\n    disable,\n    selectLastUsedLanguage,\n    toggleLastUsed,\n    selectLastUsedLanguageIfEnabled,\n    selectCaptionById,\n  };\n}\n","import { useCallback, useEffect, useMemo, useRef } from \"react\";\n\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { useVolumeStore } from \"@/stores/volume\";\n\nimport { useCaptions } from \"./useCaptions\";\n\nexport function useInitializePlayer() {\n  const display = usePlayerStore((s) => s.display);\n  const volume = useVolumeStore((s) => s.volume);\n\n  const init = useCallback(() => {\n    display?.setVolume(volume);\n  }, [display, volume]);\n\n  return {\n    init,\n  };\n}\n\nexport function useInitializeSource() {\n  const source = usePlayerStore((s) => s.source);\n  const sourceIdentifier = useMemo(\n    () => (source ? JSON.stringify(source) : null),\n    [source],\n  );\n  const { selectLastUsedLanguageIfEnabled } = useCaptions();\n\n  const funRef = useRef(selectLastUsedLanguageIfEnabled);\n  useEffect(() => {\n    funRef.current = selectLastUsedLanguageIfEnabled;\n  }, [selectLastUsedLanguageIfEnabled]);\n\n  useEffect(() => {\n    if (sourceIdentifier) funRef.current();\n  }, [sourceIdentifier]);\n}\n","import { useInitializePlayer } from \"@/components/player/hooks/useInitializePlayer\";\nimport {\n  CaptionListItem,\n  PlayerMeta,\n  PlayerStatus,\n  playerStatus,\n} from \"@/stores/player/slices/source\";\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { SourceSliceSource } from \"@/stores/player/utils/qualities\";\nimport { ProgressMediaItem, useProgressStore } from \"@/stores/progress\";\n\nexport interface Source {\n  url: string;\n  type: \"hls\" | \"mp4\";\n}\n\nfunction getProgress(\n  items: Record<string, ProgressMediaItem>,\n  meta: PlayerMeta | null,\n): number {\n  const item = items[meta?.tmdbId ?? \"\"];\n  if (!item || !meta) return 0;\n  if (meta.type === \"movie\") {\n    if (!item.progress) return 0;\n    return item.progress.watched;\n  }\n\n  const ep = item.episodes[meta.episode?.tmdbId ?? \"\"];\n  if (!ep) return 0;\n  return ep.progress.watched;\n}\n\nexport function usePlayer() {\n  const setStatus = usePlayerStore((s) => s.setStatus);\n  const setMeta = usePlayerStore((s) => s.setMeta);\n  const setSource = usePlayerStore((s) => s.setSource);\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const setSourceId = usePlayerStore((s) => s.setSourceId);\n  const status = usePlayerStore((s) => s.status);\n  const shouldStartFromBeginning = usePlayerStore(\n    (s) => s.interface.shouldStartFromBeginning,\n  );\n  const setShouldStartFromBeginning = usePlayerStore(\n    (s) => s.setShouldStartFromBeginning,\n  );\n  const reset = usePlayerStore((s) => s.reset);\n  const meta = usePlayerStore((s) => s.meta);\n  const { init } = useInitializePlayer();\n  const progressStore = useProgressStore();\n\n  return {\n    meta,\n    reset,\n    status,\n    shouldStartFromBeginning,\n    setShouldStartFromBeginning,\n    setMeta(m: PlayerMeta, newStatus?: PlayerStatus) {\n      setMeta(m, newStatus);\n    },\n    playMedia(\n      source: SourceSliceSource,\n      captions: CaptionListItem[],\n      sourceId: string | null,\n      startAtOverride?: number,\n    ) {\n      const start = startAtOverride ?? getProgress(progressStore.items, meta);\n      setCaption(null);\n      setSource(source, captions, start);\n      setSourceId(sourceId);\n      setStatus(playerStatus.PLAYING);\n      init();\n    },\n    setScrapeStatus() {\n      setStatus(playerStatus.SCRAPING);\n    },\n    setScrapeNotFound() {\n      setStatus(playerStatus.SCRAPE_NOT_FOUND);\n    },\n  };\n}\n","import { detect } from \"detect-browser\";\nimport fscreen from \"fscreen\";\nimport Hls from \"hls.js\";\n\nexport const isSafari = /^((?!chrome|android).)*safari/i.test(\n  navigator.userAgent,\n);\n\nlet cachedVolumeResult: boolean | null = null;\nexport async function canChangeVolume(): Promise<boolean> {\n  if (cachedVolumeResult === null) {\n    const timeoutPromise = new Promise<false>((resolve) => {\n      setTimeout(() => resolve(false), 1e3);\n    });\n    const promise = new Promise<true>((resolve) => {\n      const video = document.createElement(\"video\");\n      const handler = () => {\n        video.removeEventListener(\"volumechange\", handler);\n        resolve(true);\n      };\n\n      video.addEventListener(\"volumechange\", handler);\n\n      video.volume = 0.5;\n    });\n\n    cachedVolumeResult = await Promise.race([promise, timeoutPromise]);\n  }\n  return cachedVolumeResult;\n}\n\nexport function canFullscreenAnyElement(): boolean {\n  return fscreen.fullscreenEnabled;\n}\n\nexport function canWebkitFullscreen(): boolean {\n  return canFullscreenAnyElement() || isSafari;\n}\n\nexport function canFullscreen(): boolean {\n  return canFullscreenAnyElement() || canWebkitFullscreen();\n}\n\nexport function canPictureInPicture(): boolean {\n  return \"pictureInPictureEnabled\" in document;\n}\n\nexport function canWebkitPictureInPicture(): boolean {\n  return \"webkitSupportsPresentationMode\" in document.createElement(\"video\");\n}\n\nexport function canPlayHlsNatively(video: HTMLVideoElement): boolean {\n  if (Hls.isSupported()) return false; // no need to play natively\n  return !!video.canPlayType(\"application/vnd.apple.mpegurl\");\n}\n\nexport type ExtensionDetectionResult =\n  | \"unknown\" // unknown detection or weird browser\n  | \"firefox\" // firefox extensions\n  | \"chrome\" // chrome extension (could be chromium, but still works with chrome extensions)\n  | \"ios\"; // ios, no extensions\n\nexport function detectExtensionInstall(): ExtensionDetectionResult {\n  const res = detect();\n\n  // not a browser or failed to detect\n  if (res?.type !== \"browser\") return \"unknown\";\n\n  if (res.name === \"ios\" || res.name === \"ios-webview\") return \"ios\";\n  if (\n    res.name === \"chrome\" ||\n    res.name === \"chromium-webview\" ||\n    res.name === \"edge-chromium\" ||\n    res.name === \"opera\"\n  )\n    return \"chrome\";\n  if (res.name === \"firefox\") return \"firefox\";\n  return \"unknown\";\n}\n","import React, { RefObject, useCallback, useEffect, useState } from \"react\";\n\nexport type MouseActivity = React.MouseEvent<HTMLElement> | MouseEvent;\n\ntype ActivityEvent = MouseActivity | React.TouchEvent<HTMLElement> | TouchEvent;\n\nexport function makePercentageString(num: number) {\n  return `${num.toFixed(2)}%`;\n}\n\nexport function makePercentage(num: number) {\n  return Number(Math.max(0, Math.min(num, 100)).toFixed(2));\n}\n\nfunction isClickEvent(\n  evt: ActivityEvent,\n): evt is React.MouseEvent<HTMLElement> | MouseEvent {\n  return (\n    evt.type === \"mousedown\" ||\n    evt.type === \"mouseup\" ||\n    evt.type === \"mousemove\"\n  );\n}\n\nconst getEventX = (evt: ActivityEvent) => {\n  return isClickEvent(evt) ? evt.pageX : evt.changedTouches[0].pageX;\n};\n\nexport function useProgressBar(\n  barRef: RefObject<HTMLElement>,\n  commit: (percentage: number) => void,\n  commitImmediately = false,\n) {\n  const [mouseDown, setMouseDown] = useState<boolean>(false);\n  const [progress, setProgress] = useState<number>(0);\n\n  useEffect(() => {\n    function mouseMove(ev: ActivityEvent) {\n      if (!mouseDown || !barRef.current) return;\n      const rect = barRef.current.getBoundingClientRect();\n      const pos = (getEventX(ev) - rect.left) / barRef.current.offsetWidth;\n      setProgress(pos * 100);\n      if (commitImmediately) commit(pos);\n    }\n\n    function mouseUp(ev: ActivityEvent) {\n      if (!mouseDown) return;\n      setMouseDown(false);\n      document.body.removeAttribute(\"data-no-select\");\n\n      if (!barRef.current) return;\n      const rect = barRef.current.getBoundingClientRect();\n      const pos = (getEventX(ev) - rect.left) / barRef.current.offsetWidth;\n      commit(pos);\n    }\n\n    document.addEventListener(\"mousemove\", mouseMove);\n    document.addEventListener(\"touchmove\", mouseMove);\n    document.addEventListener(\"mouseup\", mouseUp);\n    document.addEventListener(\"touchend\", mouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", mouseMove);\n      document.removeEventListener(\"touchmove\", mouseMove);\n      document.removeEventListener(\"mouseup\", mouseUp);\n      document.removeEventListener(\"touchend\", mouseUp);\n    };\n  }, [mouseDown, barRef, commit, commitImmediately]);\n\n  const dragMouseDown = useCallback(\n    (ev: ActivityEvent) => {\n      setMouseDown(true);\n      document.body.setAttribute(\"data-no-select\", \"true\");\n\n      if (!barRef.current) return;\n      const rect = barRef.current.getBoundingClientRect();\n      const pos =\n        ((getEventX(ev) - rect.left) / barRef.current.offsetWidth) * 100;\n      setProgress(pos);\n    },\n    [setProgress, barRef],\n  );\n\n  return {\n    dragging: mouseDown,\n    dragPercentage: progress,\n    dragMouseDown,\n  };\n}\n","export function formatSeconds(secs: number, showHours = false): string {\n  if (Number.isNaN(secs)) {\n    if (showHours) return \"0:00:00\";\n    return \"0:00\";\n  }\n\n  let time = secs;\n  const seconds = Math.floor(time % 60);\n\n  time /= 60;\n  const minutes = Math.floor(time % 60);\n\n  time /= 60;\n  const hours = Math.floor(time);\n\n  const paddedSecs = seconds.toString().padStart(2, \"0\");\n  const paddedMins = minutes.toString().padStart(2, \"0\");\n\n  if (!showHours) return [paddedMins, paddedSecs].join(\":\");\n  return [hours, paddedMins, paddedSecs].join(\":\");\n}\n\nexport function durationExceedsHour(secs: number): boolean {\n  return secs > 60 * 60;\n}\n","import { usePlayerStore } from \"@/stores/player/store\";\nimport { useVolumeStore } from \"@/stores/volume\";\n\nexport function useVolume() {\n  const volume = usePlayerStore((s) => s.mediaPlaying.volume);\n  const lastVolume = usePlayerStore((s) => s.interface.lastVolume);\n  const setLastVolume = usePlayerStore((s) => s.setLastVolume);\n  const display = usePlayerStore((s) => s.display);\n  const setStoredVolume = useVolumeStore((s) => s.setVolume);\n\n  const toggleVolume = () => {\n    let newVolume = 0;\n\n    if (volume > 0) {\n      newVolume = 0;\n      setLastVolume(volume);\n    } else if (lastVolume > 0) newVolume = lastVolume;\n    else newVolume = 1;\n\n    display?.setVolume(newVolume);\n    setStoredVolume(newVolume);\n  };\n\n  return {\n    toggleMute() {\n      toggleVolume();\n    },\n    setVolume(vol: number) {\n      setStoredVolume(vol);\n      setLastVolume(vol);\n      display?.setVolume(vol);\n    },\n  };\n}\n","import { Stream } from \"@movie-web/providers\";\n\nimport { RULE_IDS, setDomainRule } from \"@/backend/extension/messaging\";\n\nfunction extractDomain(url: string): string | null {\n  try {\n    const u = new URL(url);\n    return u.hostname;\n  } catch {\n    return null;\n  }\n}\n\nfunction extractDomainsFromStream(stream: Stream): string[] {\n  if (stream.type === \"hls\") {\n    return [extractDomain(stream.playlist)].filter((v): v is string => !!v);\n  }\n  if (stream.type === \"file\") {\n    return Object.values(stream.qualities)\n      .map((v) => extractDomain(v.url))\n      .filter((v): v is string => !!v);\n  }\n  return [];\n}\n\nfunction buildHeadersFromStream(stream: Stream): Record<string, string> {\n  const headers: Record<string, string> = {};\n  Object.entries(stream.headers ?? {}).forEach((entry) => {\n    headers[entry[0]] = entry[1];\n  });\n  Object.entries(stream.preferredHeaders ?? {}).forEach((entry) => {\n    headers[entry[0]] = entry[1];\n  });\n  return headers;\n}\n\nexport async function prepareStream(stream: Stream) {\n  await setDomainRule({\n    ruleId: RULE_IDS.PREPARE_STREAM,\n    targetDomains: extractDomainsFromStream(stream),\n    requestHeaders: buildHeadersFromStream(stream),\n  });\n}\n","import {\n  makeProviders,\n  makeStandardFetcher,\n  targets,\n} from \"@movie-web/providers\";\n\nimport { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport {\n  makeExtensionFetcher,\n  makeLoadBalancedSimpleProxyFetcher,\n} from \"@/backend/providers/fetchers\";\n\nexport function getProviders() {\n  if (isExtensionActiveCached()) {\n    return makeProviders({\n      fetcher: makeStandardFetcher(fetch),\n      proxiedFetcher: makeExtensionFetcher(),\n      target: targets.BROWSER_EXTENSION,\n      consistentIpForRequests: true,\n    });\n  }\n\n  return makeProviders({\n    fetcher: makeStandardFetcher(fetch),\n    proxiedFetcher: makeLoadBalancedSimpleProxyFetcher(),\n    target: targets.BROWSER,\n  });\n}\n\nexport function getAllProviders() {\n  return makeProviders({\n    fetcher: makeStandardFetcher(fetch),\n    target: targets.BROWSER_EXTENSION,\n    consistentIpForRequests: true,\n  });\n}\n","import { Stream } from \"@movie-web/providers\";\n\nimport {\n  SourceFileStream,\n  SourceQuality,\n  SourceSliceSource,\n} from \"@/stores/player/utils/qualities\";\n\nconst allowedQualitiesMap: Record<SourceQuality, SourceQuality> = {\n  \"4k\": \"4k\",\n  \"1080\": \"1080\",\n  \"480\": \"480\",\n  \"360\": \"360\",\n  \"720\": \"720\",\n  unknown: \"unknown\",\n};\nconst allowedQualities = Object.keys(allowedQualitiesMap);\nconst allowedFileTypes = [\"mp4\"];\n\nfunction isAllowedQuality(inp: string): inp is SourceQuality {\n  return allowedQualities.includes(inp);\n}\n\nexport function convertRunoutputToSource(out: {\n  stream: Stream;\n}): SourceSliceSource {\n  if (out.stream.type === \"hls\") {\n    return {\n      type: \"hls\",\n      url: out.stream.playlist,\n      headers: out.stream.headers,\n      preferredHeaders: out.stream.preferredHeaders,\n    };\n  }\n  if (out.stream.type === \"file\") {\n    const qualities: Partial<Record<SourceQuality, SourceFileStream>> = {};\n    Object.entries(out.stream.qualities).forEach((entry) => {\n      if (!isAllowedQuality(entry[0])) {\n        console.warn(`unrecognized quality: ${entry[0]}`);\n        return;\n      }\n      if (!allowedFileTypes.includes(entry[1].type)) {\n        console.warn(`unrecognized file type: ${entry[1].type}`);\n        return;\n      }\n      qualities[entry[0]] = {\n        type: entry[1].type,\n        url: entry[1].url,\n      };\n    });\n    return {\n      type: \"file\",\n      qualities,\n      headers: out.stream.headers,\n      preferredHeaders: out.stream.preferredHeaders,\n    };\n  }\n  throw new Error(\"unrecognized type\");\n}\n","import {\n  EmbedOutput,\n  NotFoundError,\n  SourcererOutput,\n} from \"@movie-web/providers\";\nimport { useAsyncFn } from \"react-use\";\n\nimport { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport { prepareStream } from \"@/backend/extension/streams\";\nimport {\n  connectServerSideEvents,\n  makeProviderUrl,\n} from \"@/backend/helpers/providerApi\";\nimport {\n  scrapeSourceOutputToProviderMetric,\n  useReportProviders,\n} from \"@/backend/helpers/report\";\nimport { getLoadbalancedProviderApiUrl } from \"@/backend/providers/fetchers\";\nimport { getProviders } from \"@/backend/providers/providers\";\nimport { convertProviderCaption } from \"@/components/player/utils/captions\";\nimport { convertRunoutputToSource } from \"@/components/player/utils/convertRunoutputToSource\";\nimport { useOverlayRouter } from \"@/hooks/useOverlayRouter\";\nimport { metaToScrapeMedia } from \"@/stores/player/slices/source\";\nimport { usePlayerStore } from \"@/stores/player/store\";\n\nexport function useEmbedScraping(\n  routerId: string,\n  sourceId: string,\n  url: string,\n  embedId: string,\n) {\n  const setSource = usePlayerStore((s) => s.setSource);\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const setSourceId = usePlayerStore((s) => s.setSourceId);\n  const progress = usePlayerStore((s) => s.progress.time);\n  const meta = usePlayerStore((s) => s.meta);\n  const router = useOverlayRouter(routerId);\n  const { report } = useReportProviders();\n\n  const [request, run] = useAsyncFn(async () => {\n    const providerApiUrl = getLoadbalancedProviderApiUrl();\n    let result: EmbedOutput | undefined;\n    if (!meta) return;\n    try {\n      if (providerApiUrl && !isExtensionActiveCached()) {\n        const baseUrlMaker = makeProviderUrl(providerApiUrl);\n        const conn = await connectServerSideEvents<EmbedOutput>(\n          baseUrlMaker.scrapeEmbed(embedId, url),\n          [\"completed\", \"noOutput\"],\n        );\n        result = await conn.promise();\n      } else {\n        result = await getProviders().runEmbedScraper({\n          id: embedId,\n          url,\n        });\n      }\n    } catch (err) {\n      console.error(`Failed to scrape ${embedId}`, err);\n      const notFound = err instanceof NotFoundError;\n      const status = notFound ? \"notfound\" : \"failed\";\n      report([\n        scrapeSourceOutputToProviderMetric(\n          meta,\n          sourceId,\n          embedId,\n          status,\n          err,\n        ),\n      ]);\n      throw err;\n    }\n    report([\n      scrapeSourceOutputToProviderMetric(meta, sourceId, null, \"success\", null),\n    ]);\n    if (isExtensionActiveCached()) await prepareStream(result.stream[0]);\n    setSourceId(sourceId);\n    setCaption(null);\n    setSource(\n      convertRunoutputToSource({ stream: result.stream[0] }),\n      convertProviderCaption(result.stream[0].captions),\n      progress,\n    );\n    router.close();\n  }, [embedId, sourceId, meta, router, report, setCaption]);\n\n  return {\n    run,\n    loading: request.loading,\n    errored: !!request.error,\n  };\n}\n\nexport function useSourceScraping(sourceId: string | null, routerId: string) {\n  const meta = usePlayerStore((s) => s.meta);\n  const setSource = usePlayerStore((s) => s.setSource);\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const setSourceId = usePlayerStore((s) => s.setSourceId);\n  const progress = usePlayerStore((s) => s.progress.time);\n  const router = useOverlayRouter(routerId);\n  const { report } = useReportProviders();\n\n  const [request, run] = useAsyncFn(async () => {\n    if (!sourceId || !meta) return null;\n    const scrapeMedia = metaToScrapeMedia(meta);\n    const providerApiUrl = getLoadbalancedProviderApiUrl();\n\n    let result: SourcererOutput | undefined;\n    try {\n      if (providerApiUrl && !isExtensionActiveCached()) {\n        const baseUrlMaker = makeProviderUrl(providerApiUrl);\n        const conn = await connectServerSideEvents<SourcererOutput>(\n          baseUrlMaker.scrapeSource(sourceId, scrapeMedia),\n          [\"completed\", \"noOutput\"],\n        );\n        result = await conn.promise();\n      } else {\n        result = await getProviders().runSourceScraper({\n          id: sourceId,\n          media: scrapeMedia,\n        });\n      }\n    } catch (err) {\n      console.error(`Failed to scrape ${sourceId}`, err);\n      const notFound = err instanceof NotFoundError;\n      const status = notFound ? \"notfound\" : \"failed\";\n      report([\n        scrapeSourceOutputToProviderMetric(meta, sourceId, null, status, err),\n      ]);\n      throw err;\n    }\n    report([\n      scrapeSourceOutputToProviderMetric(meta, sourceId, null, \"success\", null),\n    ]);\n\n    if (result.stream) {\n      if (isExtensionActiveCached()) await prepareStream(result.stream[0]);\n      setCaption(null);\n      setSource(\n        convertRunoutputToSource({ stream: result.stream[0] }),\n        convertProviderCaption(result.stream[0].captions),\n        progress,\n      );\n      setSourceId(sourceId);\n      router.close();\n      return null;\n    }\n    if (result.embeds.length === 1) {\n      let embedResult: EmbedOutput | undefined;\n      if (!meta) return;\n      try {\n        if (providerApiUrl && !isExtensionActiveCached()) {\n          const baseUrlMaker = makeProviderUrl(providerApiUrl);\n          const conn = await connectServerSideEvents<EmbedOutput>(\n            baseUrlMaker.scrapeEmbed(\n              result.embeds[0].embedId,\n              result.embeds[0].url,\n            ),\n            [\"completed\", \"noOutput\"],\n          );\n          embedResult = await conn.promise();\n        } else {\n          embedResult = await getProviders().runEmbedScraper({\n            id: result.embeds[0].embedId,\n            url: result.embeds[0].url,\n          });\n        }\n      } catch (err) {\n        console.error(`Failed to scrape ${result.embeds[0].embedId}`, err);\n        const notFound = err instanceof NotFoundError;\n        const status = notFound ? \"notfound\" : \"failed\";\n        report([\n          scrapeSourceOutputToProviderMetric(\n            meta,\n            sourceId,\n            result.embeds[0].embedId,\n            status,\n            err,\n          ),\n        ]);\n        throw err;\n      }\n      report([\n        scrapeSourceOutputToProviderMetric(\n          meta,\n          sourceId,\n          result.embeds[0].embedId,\n          \"success\",\n          null,\n        ),\n      ]);\n      setSourceId(sourceId);\n      setCaption(null);\n      if (isExtensionActiveCached()) await prepareStream(embedResult.stream[0]);\n      setSource(\n        convertRunoutputToSource({ stream: embedResult.stream[0] }),\n        convertProviderCaption(embedResult.stream[0].captions),\n        progress,\n      );\n      router.close();\n    }\n    return result.embeds;\n  }, [sourceId, meta, router, setCaption]);\n\n  return {\n    run,\n    watching: (request.value ?? null) === null,\n    loading: request.loading,\n    items: request.value,\n    notfound: !!(request.error instanceof NotFoundError),\n    errored: !!request.error,\n  };\n}\n","import * as Cards from \"./Cards\";\nimport * as Links from \"./Links\";\nimport * as Misc from \"./Misc\";\nimport * as Sections from \"./Sections\";\n\nexport const Menu = {\n  ...Cards,\n  ...Links,\n  ...Sections,\n  ...Misc,\n};\n","import { useCallback, useMemo } from \"react\";\n\nimport { DetailedMeta } from \"@/backend/metadata/getmeta\";\nimport { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { usePlayer } from \"@/components/player/hooks/usePlayer\";\nimport {\n  PlayerMeta,\n  metaToScrapeMedia,\n  playerStatus,\n} from \"@/stores/player/slices/source\";\n\nexport function usePlayerMeta() {\n  const { meta, setMeta } = usePlayer();\n  const scrapeMedia = useMemo(\n    () => (meta ? metaToScrapeMedia(meta) : null),\n    [meta],\n  );\n\n  const setDirectMeta = useCallback(\n    (m: PlayerMeta) => {\n      setMeta(m, playerStatus.SCRAPING);\n    },\n    [setMeta],\n  );\n\n  const setPlayerMeta = useCallback(\n    (m: DetailedMeta, episodeId?: string) => {\n      let playerMeta: PlayerMeta;\n      if (m.meta.type === MWMediaType.SERIES) {\n        const ep = m.meta.seasonData.episodes.find((v) => v.id === episodeId);\n        if (!ep) return null;\n        playerMeta = {\n          type: \"show\",\n          releaseYear: +(m.meta.year ?? 0),\n          title: m.meta.title,\n          poster: m.meta.poster,\n          tmdbId: m.tmdbId ?? \"\",\n          imdbId: m.imdbId,\n          episodes: m.meta.seasonData.episodes.map((v) => ({\n            number: v.number,\n            title: v.title,\n            tmdbId: v.id,\n          })),\n          episode: {\n            number: ep.number,\n            title: ep.title,\n            tmdbId: ep.id,\n          },\n          season: {\n            number: m.meta.seasonData.number,\n            title: m.meta.seasonData.title,\n            tmdbId: m.meta.seasonData.id,\n          },\n        };\n      } else {\n        playerMeta = {\n          type: \"movie\",\n          releaseYear: +(m.meta.year ?? 0),\n          title: m.meta.title,\n          poster: m.meta.poster,\n          tmdbId: m.tmdbId ?? \"\",\n          imdbId: m.imdbId,\n        };\n      }\n      setDirectMeta(playerMeta);\n      return playerMeta;\n    },\n    [setDirectMeta],\n  );\n\n  return {\n    playerMeta: meta,\n    setPlayerMeta,\n    setDirectMeta,\n    scrapeMedia,\n  };\n}\n","const hasAiredCache: { [key: string]: boolean } = {};\n\nexport function hasAired(date: string) {\n  if (hasAiredCache[date]) return hasAiredCache[date];\n\n  const now = new Date();\n  const airDate = new Date(date);\n\n  hasAiredCache[date] = airDate < now;\n  return hasAiredCache[date];\n}\n","import { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport { conf } from \"@/setup/config\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nexport function isAutoplayAllowed() {\n  return Boolean(\n    conf().ALLOW_AUTOPLAY ||\n      isExtensionActiveCached() ||\n      useAuthStore.getState().proxySet,\n  );\n}\n","export function handleBuffered(time: number, buffered: TimeRanges): number {\n  for (let i = 0; i < buffered.length; i += 1) {\n    if (buffered.start(buffered.length - 1 - i) < time) {\n      return buffered.end(buffered.length - 1 - i);\n    }\n  }\n  return 0;\n}\n","const mediaErrorMap: Record<number, { name: string; key: string }> = {\n  1: {\n    name: \"MEDIA_ERR_ABORTED\",\n    key: \"player.playbackError.errors.errorAborted\",\n  },\n  2: {\n    name: \"MEDIA_ERR_NETWORK\",\n    key: \"player.playbackError.errors.errorNetwork\",\n  },\n  3: {\n    name: \"MEDIA_ERR_DECODE\",\n    key: \"player.playbackError.errors.errorDecode\",\n  },\n  4: {\n    name: \"MEDIA_ERR_SRC_NOT_SUPPORTED\",\n    key: \"player.playbackError.errors.errorNotSupported\",\n  },\n};\n\nexport function getMediaErrorDetails(\n  err: MediaError | null,\n): (typeof mediaErrorMap)[number] {\n  const item = mediaErrorMap[err?.code ?? -1];\n  if (!item) {\n    return {\n      name: \"MEDIA_ERR_GENERIC\",\n      key: \"player.playbackError.errors.errorGenericMedia\",\n    };\n  }\n  return item;\n}\n","import { conf } from \"@/setup/config\";\n\nexport function processCdnLink(url: string): string {\n  const parsedUrl = new URL(url);\n  const replacements = conf().CDN_REPLACEMENTS;\n  for (const [before, after] of replacements) {\n    if (parsedUrl.hostname.endsWith(before)) {\n      parsedUrl.hostname = after;\n      parsedUrl.port = \"\";\n      parsedUrl.protocol = \"https://\";\n      return parsedUrl.toString();\n    }\n  }\n\n  return url;\n}\n","export type EventMap = Record<string, any>;\ntype EventKey<T extends EventMap> = string & keyof T;\ntype EventReceiver<T> = (params: T) => void;\n\nexport interface Emitter<T extends EventMap> {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n}\n\nexport interface Listener<T extends EventMap> {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n}\n\nexport function makeEmitter<T extends EventMap>(): Emitter<T> {\n  const listeners: Partial<\n    Record<EventKey<T>, ((...params: any[]) => void)[]>\n  > = {};\n\n  return {\n    on(eventName, fn) {\n      if (!listeners[eventName]) listeners[eventName] = [];\n      listeners[eventName]?.push(fn);\n    },\n    off(eventName, fn) {\n      listeners[eventName] =\n        listeners[eventName]?.filter((v) => v !== fn) ?? [];\n    },\n    emit(eventName, params) {\n      (listeners[eventName] ?? []).forEach((fn) => fn(params));\n    },\n  };\n}\n","import fscreen from \"fscreen\";\nimport Hls, { Level } from \"hls.js\";\n\nimport {\n  RULE_IDS,\n  isExtensionActiveCached,\n  setDomainRule,\n} from \"@/backend/extension/messaging\";\nimport {\n  DisplayInterface,\n  DisplayInterfaceEvents,\n} from \"@/components/player/display/displayInterface\";\nimport { handleBuffered } from \"@/components/player/utils/handleBuffered\";\nimport { getMediaErrorDetails } from \"@/components/player/utils/mediaErrorDetails\";\nimport { useLanguageStore } from \"@/stores/language\";\nimport {\n  LoadableSource,\n  SourceQuality,\n  getPreferredQuality,\n} from \"@/stores/player/utils/qualities\";\nimport { processCdnLink } from \"@/utils/cdn\";\nimport {\n  canChangeVolume,\n  canFullscreen,\n  canFullscreenAnyElement,\n  canPictureInPicture,\n  canPlayHlsNatively,\n  canWebkitFullscreen,\n  canWebkitPictureInPicture,\n} from \"@/utils/detectFeatures\";\nimport { makeEmitter } from \"@/utils/events\";\n\nconst levelConversionMap: Record<number, SourceQuality> = {\n  360: \"360\",\n  1080: \"1080\",\n  720: \"720\",\n  480: \"480\",\n};\n\nfunction hlsLevelToQuality(level?: Level): SourceQuality | null {\n  return levelConversionMap[level?.height ?? 0] ?? null;\n}\n\nfunction qualityToHlsLevel(quality: SourceQuality): number | null {\n  const found = Object.entries(levelConversionMap).find(\n    (entry) => entry[1] === quality,\n  );\n  return found ? +found[0] : null;\n}\n\nfunction hlsLevelsToQualities(levels: Level[]): SourceQuality[] {\n  return levels\n    .map((v) => hlsLevelToQuality(v))\n    .filter((v): v is SourceQuality => !!v);\n}\n\nexport function makeVideoElementDisplayInterface(): DisplayInterface {\n  const { emit, on, off } = makeEmitter<DisplayInterfaceEvents>();\n  let source: LoadableSource | null = null;\n  let hls: Hls | null = null;\n  let videoElement: HTMLVideoElement | null = null;\n  let containerElement: HTMLElement | null = null;\n  let isFullscreen = false;\n  let isPausedBeforeSeeking = false;\n  let isSeeking = false;\n  let startAt = 0;\n  let automaticQuality = false;\n  let preferenceQuality: SourceQuality | null = null;\n  let lastVolume = 1;\n\n  const languagePromises = new Map<\n    string,\n    (value: void | PromiseLike<void>) => void\n  >();\n\n  function reportLevels() {\n    if (!hls) return;\n    const levels = hls.levels;\n    const convertedLevels = levels\n      .map((v) => hlsLevelToQuality(v))\n      .filter((v): v is SourceQuality => !!v);\n    emit(\"qualities\", convertedLevels);\n  }\n\n  function reportAudioTracks() {\n    if (!hls) return;\n    const currentLanguage = useLanguageStore.getState().language;\n    const audioTracks = hls.audioTracks;\n    const languageTrack = audioTracks.find((v) => v.lang === currentLanguage);\n    if (languageTrack) {\n      hls.audioTrack = audioTracks.indexOf(languageTrack);\n    }\n    const currentTrack = audioTracks?.[hls.audioTrack ?? 0];\n    if (!currentTrack) return;\n    emit(\"changedaudiotrack\", {\n      id: currentTrack.id.toString(),\n      label: currentTrack.name,\n      language: currentTrack.lang ?? \"unknown\",\n    });\n    emit(\n      \"audiotracks\",\n      hls.audioTracks.map((v) => ({\n        id: v.id.toString(),\n        label: v.name,\n        language: v.lang ?? \"unknown\",\n      })),\n    );\n  }\n\n  function setupQualityForHls() {\n    if (videoElement && canPlayHlsNatively(videoElement)) {\n      return; // nothing to change\n    }\n\n    if (!hls) return;\n    if (!automaticQuality) {\n      const qualities = hlsLevelsToQualities(hls.levels);\n      const availableQuality = getPreferredQuality(qualities, {\n        lastChosenQuality: preferenceQuality,\n        automaticQuality,\n      });\n      if (availableQuality) {\n        const levelIndex = hls.levels.findIndex(\n          (v) => v.height === qualityToHlsLevel(availableQuality),\n        );\n        if (levelIndex !== -1) {\n          hls.currentLevel = levelIndex;\n          hls.loadLevel = levelIndex;\n        }\n      }\n    } else {\n      hls.currentLevel = -1;\n      hls.loadLevel = -1;\n    }\n    const quality = hlsLevelToQuality(hls.levels[hls.currentLevel]);\n    emit(\"changedquality\", quality);\n  }\n\n  function setupSource(vid: HTMLVideoElement, src: LoadableSource) {\n    hls = null;\n    if (src.type === \"hls\") {\n      if (canPlayHlsNatively(vid)) {\n        vid.src = processCdnLink(src.url);\n        vid.currentTime = startAt;\n        return;\n      }\n\n      if (!Hls.isSupported()) throw new Error(\"HLS not supported\");\n      if (!hls) {\n        hls = new Hls({\n          maxBufferSize: 500 * 1000 * 1000, // 500 mb of buffering, should load more fragments at once\n          fragLoadPolicy: {\n            default: {\n              maxLoadTimeMs: 30 * 1000, // allow it load extra long, fragments are slow if requested for the first time on an origin\n              maxTimeToFirstByteMs: 30 * 1000,\n              errorRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000,\n              },\n              timeoutRetry: {\n                maxNumRetry: 3,\n                maxRetryDelayMs: 0,\n                retryDelayMs: 0,\n              },\n            },\n          },\n          renderTextTracksNatively: false,\n        });\n        hls.on(Hls.Events.ERROR, (event, data) => {\n          console.error(\"HLS error\", data);\n          if (data.fatal && src?.url === data.frag?.baseurl) {\n            emit(\"error\", {\n              message: data.error.message,\n              stackTrace: data.error.stack,\n              errorName: data.error.name,\n              type: \"hls\",\n            });\n          }\n        });\n        hls.on(Hls.Events.MANIFEST_LOADED, () => {\n          if (!hls) return;\n          reportLevels();\n          setupQualityForHls();\n          reportAudioTracks();\n\n          if (isExtensionActiveCached()) {\n            hls.on(Hls.Events.LEVEL_LOADED, async (_, data) => {\n              const chunkUrlsDomains = data.details.fragments.map(\n                (v) => new URL(v.url).hostname,\n              );\n              const chunkUrls = [...new Set(chunkUrlsDomains)];\n\n              await setDomainRule({\n                ruleId: RULE_IDS.SET_DOMAINS_HLS,\n                targetDomains: chunkUrls,\n                requestHeaders: {\n                  ...src.preferredHeaders,\n                  ...src.headers,\n                },\n              });\n            });\n            hls.on(Hls.Events.AUDIO_TRACK_LOADED, async (_, data) => {\n              const chunkUrlsDomains = data.details.fragments.map(\n                (v) => new URL(v.url).hostname,\n              );\n              const chunkUrls = [...new Set(chunkUrlsDomains)];\n\n              await setDomainRule({\n                ruleId: RULE_IDS.SET_DOMAINS_HLS_AUDIO,\n                targetDomains: chunkUrls,\n                requestHeaders: {\n                  ...src.preferredHeaders,\n                  ...src.headers,\n                },\n              });\n            });\n          }\n        });\n        hls.on(Hls.Events.LEVEL_SWITCHED, () => {\n          if (!hls) return;\n          const quality = hlsLevelToQuality(hls.levels[hls.currentLevel]);\n          emit(\"changedquality\", quality);\n        });\n        hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, () => {\n          for (const [lang, resolve] of languagePromises) {\n            const track = hls?.subtitleTracks.find((t) => t.lang === lang);\n            if (track) {\n              resolve();\n              languagePromises.delete(lang);\n              break;\n            }\n          }\n        });\n      }\n\n      hls.attachMedia(vid);\n      hls.loadSource(processCdnLink(src.url));\n      vid.currentTime = startAt;\n      return;\n    }\n\n    vid.src = processCdnLink(src.url);\n    vid.currentTime = startAt;\n  }\n\n  function setSource() {\n    if (!videoElement || !source) return;\n    setupSource(videoElement, source);\n\n    videoElement.addEventListener(\"play\", () => {\n      emit(\"play\", undefined);\n      emit(\"loading\", false);\n    });\n    videoElement.addEventListener(\"error\", () => {\n      const err = videoElement?.error ?? null;\n      const errorDetails = getMediaErrorDetails(err);\n      emit(\"error\", {\n        errorName: errorDetails.name,\n        key: errorDetails.key,\n        type: \"htmlvideo\",\n      });\n    });\n    videoElement.addEventListener(\"playing\", () => emit(\"play\", undefined));\n    videoElement.addEventListener(\"pause\", () => emit(\"pause\", undefined));\n    videoElement.addEventListener(\"canplay\", () => emit(\"loading\", false));\n    videoElement.addEventListener(\"waiting\", () => emit(\"loading\", true));\n    videoElement.addEventListener(\"volumechange\", () =>\n      emit(\n        \"volumechange\",\n        videoElement?.muted ? 0 : (videoElement?.volume ?? 0),\n      ),\n    );\n    videoElement.addEventListener(\"timeupdate\", () =>\n      emit(\"time\", videoElement?.currentTime ?? 0),\n    );\n    videoElement.addEventListener(\"loadedmetadata\", () => {\n      if (\n        source?.type === \"hls\" &&\n        videoElement &&\n        canPlayHlsNatively(videoElement)\n      ) {\n        emit(\"qualities\", [\"unknown\"]);\n        emit(\"changedquality\", \"unknown\");\n      }\n      emit(\"duration\", videoElement?.duration ?? 0);\n    });\n    videoElement.addEventListener(\"progress\", () => {\n      if (videoElement)\n        emit(\n          \"buffered\",\n          handleBuffered(videoElement.currentTime, videoElement.buffered),\n        );\n    });\n    videoElement.addEventListener(\"webkitendfullscreen\", () => {\n      isFullscreen = false;\n      emit(\"fullscreen\", isFullscreen);\n      if (!isFullscreen) emit(\"needstrack\", false);\n    });\n    videoElement.addEventListener(\n      \"webkitplaybacktargetavailabilitychanged\",\n      (e: any) => {\n        if (e.availability === \"available\") {\n          emit(\"canairplay\", true);\n        }\n      },\n    );\n    videoElement.addEventListener(\"ratechange\", () => {\n      if (videoElement) emit(\"playbackrate\", videoElement.playbackRate);\n    });\n  }\n\n  function unloadSource() {\n    if (videoElement) {\n      videoElement.removeAttribute(\"src\");\n      videoElement.load();\n    }\n    if (hls) {\n      hls.destroy();\n      hls = null;\n    }\n  }\n\n  function destroyVideoElement() {\n    unloadSource();\n    if (videoElement) {\n      videoElement = null;\n    }\n  }\n\n  function fullscreenChange() {\n    isFullscreen =\n      !!document.fullscreenElement || // other browsers\n      !!(document as any).webkitFullscreenElement; // safari\n    emit(\"fullscreen\", isFullscreen);\n    if (!isFullscreen) emit(\"needstrack\", false);\n  }\n  fscreen.addEventListener(\"fullscreenchange\", fullscreenChange);\n\n  return {\n    on,\n    off,\n    getType() {\n      return \"web\";\n    },\n    destroy: () => {\n      destroyVideoElement();\n      fscreen.removeEventListener(\"fullscreenchange\", fullscreenChange);\n    },\n    load(ops) {\n      if (!ops.source) unloadSource();\n      automaticQuality = ops.automaticQuality;\n      preferenceQuality = ops.preferredQuality;\n      source = ops.source;\n      emit(\"loading\", true);\n      startAt = ops.startAt;\n      setSource();\n    },\n    changeQuality(newAutomaticQuality, newPreferredQuality) {\n      if (source?.type !== \"hls\") return;\n      automaticQuality = newAutomaticQuality;\n      preferenceQuality = newPreferredQuality;\n      setupQualityForHls();\n    },\n\n    processVideoElement(video) {\n      destroyVideoElement();\n      videoElement = video;\n      setSource();\n      this.setVolume(lastVolume);\n    },\n    processContainerElement(container) {\n      containerElement = container;\n    },\n    setMeta() {},\n    setCaption() {},\n\n    pause() {\n      videoElement?.pause();\n    },\n    play() {\n      videoElement?.play();\n    },\n    setSeeking(active) {\n      if (active === isSeeking) return;\n      isSeeking = active;\n\n      // if it was playing when starting to seek, play again\n      if (!active) {\n        if (!isPausedBeforeSeeking) this.play();\n        return;\n      }\n\n      isPausedBeforeSeeking = videoElement?.paused ?? true;\n      this.pause();\n    },\n    setTime(t) {\n      if (!videoElement) return;\n      // clamp time between 0 and max duration\n      let time = Math.min(t, videoElement.duration);\n      time = Math.max(0, time);\n\n      if (Number.isNaN(time)) return;\n      emit(\"time\", time);\n      videoElement.currentTime = time;\n    },\n    async setVolume(v) {\n      // clamp time between 0 and 1\n      let volume = Math.min(v, 1);\n      volume = Math.max(0, volume);\n\n      // actually set\n      lastVolume = v;\n      if (!videoElement) return;\n      videoElement.muted = volume === 0; // Muted attribute is always supported\n\n      // update state\n      const isChangeable = await canChangeVolume();\n      if (isChangeable) {\n        videoElement.volume = volume;\n      } else {\n        // For browsers where it can't be changed\n        emit(\"volumechange\", volume === 0 ? 0 : 1);\n      }\n    },\n    toggleFullscreen() {\n      if (isFullscreen) {\n        isFullscreen = false;\n        emit(\"fullscreen\", isFullscreen);\n        emit(\"needstrack\", false);\n        if (!fscreen.fullscreenElement) return;\n        fscreen.exitFullscreen();\n        return;\n      }\n\n      // enter fullscreen\n      isFullscreen = true;\n      emit(\"fullscreen\", isFullscreen);\n      if (!canFullscreen() || fscreen.fullscreenElement) return;\n      if (canFullscreenAnyElement()) {\n        if (containerElement) fscreen.requestFullscreen(containerElement);\n        return;\n      }\n      if (canWebkitFullscreen()) {\n        if (videoElement) {\n          emit(\"needstrack\", true);\n          (videoElement as any).webkitEnterFullscreen();\n        }\n      }\n    },\n    togglePictureInPicture() {\n      if (!videoElement) return;\n      if (canWebkitPictureInPicture()) {\n        const webkitPlayer = videoElement as any;\n        webkitPlayer.webkitSetPresentationMode(\n          webkitPlayer.webkitPresentationMode === \"picture-in-picture\"\n            ? \"inline\"\n            : \"picture-in-picture\",\n        );\n      }\n      if (canPictureInPicture()) {\n        if (videoElement !== document.pictureInPictureElement) {\n          videoElement.requestPictureInPicture();\n        } else {\n          document.exitPictureInPicture();\n        }\n      }\n    },\n    startAirplay() {\n      const videoPlayer = videoElement as any;\n      if (videoPlayer && videoPlayer.webkitShowPlaybackTargetPicker) {\n        videoPlayer.webkitShowPlaybackTargetPicker();\n      }\n    },\n    setPlaybackRate(rate) {\n      if (videoElement) videoElement.playbackRate = rate;\n    },\n    getCaptionList() {\n      return (\n        hls?.subtitleTracks.map((track) => {\n          return {\n            id: track.id.toString(),\n            language: track.lang ?? \"unknown\",\n            url: track.url,\n            needsProxy: false,\n            hls: true,\n          };\n        }) ?? []\n      );\n    },\n    getSubtitleTracks() {\n      return hls?.subtitleTracks ?? [];\n    },\n    async setSubtitlePreference(lang) {\n      // default subtitles are already loaded by hls.js\n      const track = hls?.subtitleTracks.find((t) => t.lang === lang);\n      if (track?.details !== undefined) return Promise.resolve();\n\n      // need to wait a moment before hls loads the subtitles\n      const promise = new Promise<void>((resolve, reject) => {\n        languagePromises.set(lang, resolve);\n\n        // reject after some time, if hls.js fails to load the subtitles\n        // for any reason\n        setTimeout(() => {\n          reject();\n          languagePromises.delete(lang);\n        }, 5000);\n      });\n      hls?.setSubtitleOption({ lang });\n      return promise;\n    },\n    changeAudioTrack(track) {\n      if (!hls) return;\n      const audioTrack = hls?.audioTracks.find(\n        (t) => t.id.toString() === track.id,\n      );\n      if (!audioTrack) return;\n      hls.audioTrack = hls.audioTracks.indexOf(audioTrack);\n      emit(\"changedaudiotrack\", {\n        id: audioTrack.id.toString(),\n        label: audioTrack.name,\n        language: audioTrack.lang ?? \"unknown\",\n      });\n    },\n  };\n}\n","import fscreen from \"fscreen\";\n\nimport { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport {\n  DisplayCaption,\n  DisplayInterface,\n  DisplayInterfaceEvents,\n  DisplayMeta,\n} from \"@/components/player/display/displayInterface\";\nimport { LoadableSource } from \"@/stores/player/utils/qualities\";\nimport { processCdnLink } from \"@/utils/cdn\";\nimport {\n  canChangeVolume,\n  canFullscreen,\n  canFullscreenAnyElement,\n} from \"@/utils/detectFeatures\";\nimport { makeEmitter } from \"@/utils/events\";\n\nexport interface ChromeCastDisplayInterfaceOptions {\n  controller: cast.framework.RemotePlayerController;\n  player: cast.framework.RemotePlayer;\n  instance: cast.framework.CastContext;\n}\n\n/*\n ** Chromecasting is unfinished, here is its limitations:\n **  1. Captions - chromecast requires only VTT, but needs it from a URL. we only have SRT urls\n **  2. HLS - we've having some issues with content types. sometimes it loads, sometimes it doesn't\n */\n\nexport function makeChromecastDisplayInterface(\n  ops: ChromeCastDisplayInterfaceOptions,\n): DisplayInterface {\n  const { emit, on, off } = makeEmitter<DisplayInterfaceEvents>();\n  let isPaused = false;\n  let playbackRate = 1;\n  let source: LoadableSource | null = null;\n  let videoElement: HTMLVideoElement | null = null;\n  let containerElement: HTMLElement | null = null;\n  let isFullscreen = false;\n  let isPausedBeforeSeeking = false;\n  let isSeeking = false;\n  let startAt = 0;\n  let meta: DisplayMeta = {\n    title: \"\",\n    type: MWMediaType.MOVIE,\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  let caption: DisplayCaption | null = null;\n\n  function listenForEvents() {\n    const listen = async (e: cast.framework.RemotePlayerChangedEvent) => {\n      switch (e.field) {\n        case \"volumeLevel\":\n          if (await canChangeVolume()) emit(\"volumechange\", e.value);\n          break;\n        case \"currentTime\":\n          emit(\"time\", e.value);\n          break;\n        case \"duration\":\n          emit(\"duration\", e.value ?? 0);\n          break;\n        case \"mediaInfo\":\n          if (e.value) emit(\"duration\", e.value.duration ?? 0);\n          break;\n        case \"playerState\":\n          emit(\"loading\", e.value === \"BUFFERING\");\n          if (e.value === \"PLAYING\") emit(\"play\", undefined);\n          else if (e.value === \"PAUSED\") emit(\"pause\", undefined);\n          isPaused = e.value === \"PAUSED\";\n          break;\n        case \"isMuted\":\n          emit(\"volumechange\", e.value ? 1 : 0);\n          break;\n        case \"displayStatus\":\n        case \"canSeek\":\n        case \"title\":\n        case \"isPaused\":\n        case \"canPause\":\n        case \"isMediaLoaded\":\n        case \"statusText\":\n        case \"isConnected\":\n        case \"displayName\":\n        case \"canControlVolume\":\n        case \"savedPlayerState\":\n          break;\n        default:\n          break;\n      }\n    };\n    ops.controller?.addEventListener(\n      cast.framework.RemotePlayerEventType.ANY_CHANGE,\n      listen,\n    );\n    return () => {\n      ops.controller?.removeEventListener(\n        cast.framework.RemotePlayerEventType.ANY_CHANGE,\n        listen,\n      );\n    };\n  }\n\n  function setupSource() {\n    if (!source) {\n      ops.controller?.stop();\n      return;\n    }\n\n    let type = \"video/mp4\";\n    if (source.type === \"hls\") type = \"application/x-mpegurl\";\n\n    const metaData = new chrome.cast.media.GenericMediaMetadata();\n    metaData.title = meta.title;\n\n    const mediaInfo = new chrome.cast.media.MediaInfo(\"video\", type);\n    (mediaInfo as any).contentUrl = processCdnLink(source.url);\n    mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n    mediaInfo.metadata = metaData;\n    mediaInfo.customData = {\n      playbackRate,\n    };\n\n    const request = new chrome.cast.media.LoadRequest(mediaInfo);\n    request.autoplay = true;\n    request.currentTime = startAt;\n\n    if (source.type === \"hls\") {\n      const staticMedia = chrome.cast.media as any;\n      const media = request.media as any;\n      media.hlsSegmentFormat = staticMedia.HlsSegmentFormat.FMP4;\n      media.hlsVideoSegmentFormat = staticMedia.HlsVideoSegmentFormat.FMP4;\n    }\n\n    const session = ops.instance.getCurrentSession();\n    session?.loadMedia(request);\n  }\n\n  function setSource() {\n    if (!videoElement || !source) return;\n    setupSource();\n  }\n\n  function destroyVideoElement() {\n    if (videoElement) videoElement = null;\n  }\n\n  function fullscreenChange() {\n    isFullscreen =\n      !!document.fullscreenElement || // other browsers\n      !!(document as any).webkitFullscreenElement; // safari\n    emit(\"fullscreen\", isFullscreen);\n    if (!isFullscreen) emit(\"needstrack\", false);\n  }\n  fscreen.addEventListener(\"fullscreenchange\", fullscreenChange);\n\n  // start listening immediately\n  const stopListening = listenForEvents();\n\n  return {\n    on,\n    off,\n    getType() {\n      return \"casting\";\n    },\n    destroy: () => {\n      stopListening();\n      destroyVideoElement();\n      fscreen.removeEventListener(\"fullscreenchange\", fullscreenChange);\n    },\n    load(loadOps) {\n      source = loadOps.source;\n      emit(\"loading\", true);\n      startAt = loadOps.startAt;\n      setSource();\n    },\n    changeQuality() {\n      // cant control qualities\n    },\n    setCaption(newCaption) {\n      caption = newCaption;\n      setSource();\n    },\n\n    processVideoElement(video) {\n      destroyVideoElement();\n      videoElement = video;\n      setSource();\n    },\n    processContainerElement(container) {\n      containerElement = container;\n    },\n    setMeta(data) {\n      meta = data;\n      setSource();\n    },\n\n    pause() {\n      if (!isPaused) {\n        ops.controller.playOrPause();\n        isPaused = true;\n      }\n    },\n    play() {\n      if (isPaused) {\n        ops.controller.playOrPause();\n        isPaused = false;\n      }\n    },\n    setSeeking(active) {\n      if (active === isSeeking) return;\n      isSeeking = active;\n\n      // if it was playing when starting to seek, play again\n      if (!active) {\n        if (!isPausedBeforeSeeking) this.play();\n        return;\n      }\n\n      isPausedBeforeSeeking = isPaused ?? true;\n      this.pause();\n    },\n    setTime(t) {\n      if (!videoElement) return;\n      // clamp time between 0 and max duration\n      let time = Math.min(t, ops.player.duration);\n      time = Math.max(0, time);\n\n      if (Number.isNaN(time)) return;\n      emit(\"time\", time);\n      ops.player.currentTime = time;\n      ops.controller.seek();\n    },\n    async setVolume(v) {\n      // clamp time between 0 and 1\n      let volume = Math.min(v, 1);\n      volume = Math.max(0, volume);\n\n      // update state\n      const isChangeable = await canChangeVolume();\n      if (isChangeable) {\n        ops.player.volumeLevel = volume;\n        ops.controller.setVolumeLevel();\n        emit(\"volumechange\", volume);\n      } else {\n        // For browsers where it can't be changed\n        emit(\"volumechange\", volume === 0 ? 0 : 1);\n      }\n    },\n    toggleFullscreen() {\n      if (isFullscreen) {\n        isFullscreen = false;\n        emit(\"fullscreen\", isFullscreen);\n        emit(\"needstrack\", false);\n        if (!fscreen.fullscreenElement) return;\n        fscreen.exitFullscreen();\n        return;\n      }\n\n      // enter fullscreen\n      isFullscreen = true;\n      emit(\"fullscreen\", isFullscreen);\n      if (!canFullscreen() || fscreen.fullscreenElement) return;\n      if (canFullscreenAnyElement()) {\n        if (containerElement) fscreen.requestFullscreen(containerElement);\n      }\n    },\n    togglePictureInPicture() {\n      // Can't PIP while Chromecasting\n    },\n    startAirplay() {\n      // cant airplay while chromecasting\n    },\n    setPlaybackRate(rate) {\n      playbackRate = rate;\n      setSource();\n    },\n    getCaptionList() {\n      return [];\n    },\n    getSubtitleTracks() {\n      return [];\n    },\n    async setSubtitlePreference() {\n      return Promise.resolve();\n    },\n    changeAudioTrack() {\n      // cant change audio tracks\n    },\n  };\n}\n","const CHROMECAST_SENDER_SDK =\n  \"https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\";\n\nconst callbacks: ((available: boolean) => void)[] = [];\nlet _available: boolean | null = null;\n\nfunction init(available: boolean) {\n  _available = available;\n  callbacks.forEach((cb) => cb(available));\n}\n\nexport function isChromecastAvailable(cb: (available: boolean) => void) {\n  if (_available !== null) return cb(_available);\n  callbacks.push(cb);\n}\n\nexport function initializeChromecast() {\n  window.__onGCastApiAvailable = (isAvailable) => {\n    init(isAvailable);\n  };\n\n  // add script if doesnt exist yet\n  const exists = !!document.getElementById(\"chromecast-script\");\n  if (!exists) {\n    const script = document.createElement(\"script\");\n    script.setAttribute(\"src\", CHROMECAST_SENDER_SDK);\n    script.setAttribute(\"id\", \"chromecast-script\");\n    document.body.appendChild(script);\n  }\n}\n","/// <reference types=\"chromecast-caf-sender\"/>\n\nimport { useEffect, useState } from \"react\";\n\nimport { isChromecastAvailable } from \"@/setup/chromecast\";\n\nexport function useChromecastAvailable() {\n  const [available, setAvailable] = useState<boolean | null>(null);\n\n  useEffect(() => {\n    isChromecastAvailable((bool) => setAvailable(bool));\n  }, []);\n\n  return available;\n}\n","/* Define shit here */\n\n// Define the Media type\nexport interface Media {\n  id: number;\n  poster_path: string;\n  title?: string;\n  name?: string;\n}\n\n// Update the Movie and TVShow interfaces to extend the Media interface\nexport interface Movie extends Media {\n  title: string;\n}\n\nexport interface TVShow extends Media {\n  name: string;\n}\n\n// Define the Genre type\nexport interface Genre {\n  id: number;\n  name: string;\n}\n\n// Define the Category type\nexport interface Category {\n  name: string;\n  endpoint: string;\n}\n\n// Define the categories\nexport const categories: Category[] = [\n  {\n    name: \"Now Playing\",\n    endpoint: \"/movie/now_playing?language=en-US\",\n  },\n  {\n    name: \"Top Rated\",\n    endpoint: \"/movie/top_rated?language=en-US\",\n  },\n  {\n    name: \"Most Popular\",\n    endpoint: \"/movie/popular?language=en-US\",\n  },\n];\n\nexport const tvCategories: Category[] = [\n  {\n    name: \"Top Rated\",\n    endpoint: \"/tv/top_rated?language=en-US\",\n  },\n  {\n    name: \"Most Popular\",\n    endpoint: \"/tv/popular?language=en-US\",\n  },\n];\n","import { useEffect, useState } from \"react\";\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","import { useCallback, useMemo } from \"react\";\nimport { useTranslation } from \"react-i18next\";\n\n// 35% chance of getting a joke title (Cooper done changed this code!)\nconst shouldGiveJokeTitle = () => Math.random() < 0.35;\n\nexport function useRandomTranslation() {\n  const { t } = useTranslation();\n  const shouldJoke = useMemo(() => shouldGiveJokeTitle(), []);\n  const seed = useMemo(() => Math.random(), []);\n\n  const getRandomTranslation = useCallback(\n    (key: string): string => {\n      const defaultTitle = t(`${key}.default`) ?? \"\";\n      if (!shouldJoke) return defaultTitle;\n\n      const keys = t(`${key}.extra`, {\n        returnObjects: true,\n        defaultValue: defaultTitle,\n      });\n      if (Array.isArray(keys)) {\n        if (keys.length === 0) return defaultTitle;\n        return keys[Math.floor(seed * keys.length)];\n      }\n\n      return typeof keys === \"string\" ? keys : defaultTitle;\n    },\n    [t, seed, shouldJoke],\n  );\n\n  return { t: getRandomTranslation };\n}\n","import { useEffect, useState } from \"react\";\nimport { generatePath, useNavigate, useParams } from \"react-router-dom\";\n\nfunction decode(query: string | null | undefined) {\n  return query ? decodeURIComponent(query) : \"\";\n}\n\nexport function useSearchQuery(): [\n  string,\n  (inp: string, force?: boolean) => void,\n  () => void,\n] {\n  const navigate = useNavigate();\n  const params = useParams<{ query: string }>();\n  const [search, setSearch] = useState(decode(params.query));\n\n  useEffect(() => {\n    setSearch(decode(params.query));\n  }, [params.query]);\n\n  const updateParams = (inp: string, commitToUrl = false) => {\n    setSearch(inp);\n    if (!commitToUrl) return;\n    if (inp.length === 0) {\n      navigate(\"/\", { replace: true });\n      return;\n    }\n    navigate(\n      generatePath(\"/browse/:query\", {\n        query: inp,\n      }),\n      { replace: true },\n    );\n  };\n\n  const onUnFocus = (newSearch?: string) => {\n    updateParams(newSearch ?? search, true);\n  };\n\n  return [search, updateParams, onUnFocus];\n}\n","import {\n  ProgressEpisodeItem,\n  ProgressItem,\n  ProgressMediaItem,\n  ProgressSeasonItem,\n} from \"@/stores/progress\";\n\nexport interface ShowProgressResult {\n  episode?: ProgressEpisodeItem;\n  season?: ProgressSeasonItem;\n  progress: ProgressItem;\n  show: boolean;\n}\n\nconst defaultProgress = {\n  duration: 0,\n  watched: 0,\n};\n\nfunction progressIsCompleted(duration: number, watched: number): boolean {\n  const timeFromEnd = duration - watched;\n\n  // too close to the end, is completed\n  if (timeFromEnd < 60 * 2) return true;\n\n  // satisfies all constraints, not completed\n  return false;\n}\n\nfunction progressIsNotStarted(duration: number, watched: number): boolean {\n  // too short watch time\n  if (watched < 20) return true;\n\n  // satisfies all constraints, not completed\n  return false;\n}\n\nfunction progressIsAcceptableRange(duration: number, watched: number): boolean {\n  // not started enough yet, not acceptable\n  if (progressIsNotStarted(duration, watched)) return false;\n\n  // is already at the end, not acceptable\n  if (progressIsCompleted(duration, watched)) return false;\n\n  // satisfied all constraints\n  return true;\n}\n\nfunction isFirstEpisodeOfShow(\n  item: ProgressMediaItem,\n  episode: ProgressEpisodeItem,\n): boolean {\n  const seasonId = episode.seasonId;\n  const season = item.seasons[seasonId];\n  return season.number === 1 && episode.number === 1;\n}\n\nexport function shouldShowProgress(\n  item: ProgressMediaItem,\n): ShowProgressResult {\n  // non shows just hide or show depending on acceptable ranges\n  if (item.type !== \"show\") {\n    return {\n      show: progressIsAcceptableRange(\n        item.progress?.duration ?? 0,\n        item.progress?.watched ?? 0,\n      ),\n      progress: item.progress ?? defaultProgress,\n    };\n  }\n\n  // shows only hide an item if its too early in episode, it still shows if its near the end.\n  // Otherwise you would lose episode progress\n  const ep = Object.values(item.episodes)\n    .sort((a, b) => b.updatedAt - a.updatedAt)\n    .filter(\n      (epi) =>\n        !progressIsNotStarted(epi.progress.duration, epi.progress.watched) ||\n        !isFirstEpisodeOfShow(item, epi),\n    )[0];\n\n  const season = item.seasons[ep?.seasonId];\n  if (!ep || !season)\n    return {\n      show: false,\n      progress: defaultProgress,\n    };\n  return {\n    season,\n    episode: ep,\n    show: true,\n    progress: ep.progress,\n  };\n}\n","import { useEffect } from \"react\";\n\nexport function useSlashFocus(ref: React.RefObject<HTMLInputElement>) {\n  useEffect(() => {\n    const listener = (e: KeyboardEvent) => {\n      if (e.key === \"/\") {\n        if (\n          document.activeElement &&\n          document.activeElement.tagName.toLowerCase() === \"input\"\n        )\n          return;\n        e.preventDefault();\n        ref.current?.focus();\n      }\n    };\n\n    window.addEventListener(\"keydown\", listener);\n    return () => {\n      window.removeEventListener(\"keydown\", listener);\n    };\n  }, [ref]);\n}\n","import { useCallback } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nimport { useQueryParam } from \"@/hooks/useQueryParams\";\nimport { useOnboardingStore } from \"@/stores/onboarding\";\n\nexport function useRedirectBack() {\n  const [url] = useQueryParam(\"redirect\");\n  const navigate = useNavigate();\n  const setCompleted = useOnboardingStore((s) => s.setCompleted);\n\n  const redirectBack = useCallback(() => {\n    navigate(url ?? \"/\");\n  }, [navigate, url]);\n\n  const completeAndRedirect = useCallback(() => {\n    setCompleted(true);\n    redirectBack();\n  }, [redirectBack, setCompleted]);\n\n  return { completeAndRedirect };\n}\n\nexport function useNavigateOnboarding() {\n  const navigate = useNavigate();\n  const loc = useLocation();\n  const nav = useCallback(\n    (path: string) => {\n      navigate({\n        pathname: path,\n        search: loc.search,\n      });\n    },\n    [navigate, loc],\n  );\n  return nav;\n}\n","import { isAllowedExtensionVersion } from \"@/backend/extension/compatibility\";\nimport { extensionInfo } from \"@/backend/extension/messaging\";\n\nexport type ExtensionStatus =\n  | \"unknown\"\n  | \"failed\"\n  | \"disallowed\"\n  | \"noperms\"\n  | \"outdated\"\n  | \"success\";\n\nexport async function getExtensionState(): Promise<ExtensionStatus> {\n  const info = await extensionInfo();\n  if (!info) return \"unknown\"; // cant talk to extension\n  if (!info.success) return \"failed\"; // extension failed to respond\n  if (!info.allowed) return \"disallowed\"; // extension is not enabled on this page\n  if (!info.hasPermission) return \"noperms\"; // extension has no perms to do it's tasks\n  if (!isAllowedExtensionVersion(info.version)) return \"outdated\"; // extension is too old\n  return \"success\"; // no problems\n}\n","import { useEffect, useMemo } from \"react\";\nimport { useLocation } from \"react-router-dom\";\nimport { useEffectOnce } from \"react-use\";\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\ninterface HistoryRoute {\n  path: string;\n}\n\ninterface HistoryStore {\n  routes: HistoryRoute[];\n  registerRoute(route: HistoryRoute): void;\n}\n\nexport const useHistoryStore = create(\n  immer<HistoryStore>((set) => ({\n    routes: [],\n    registerRoute(route) {\n      set((s) => {\n        s.routes.push(route);\n      });\n    },\n  })),\n);\n\nexport function useHistoryListener() {\n  const location = useLocation();\n  const registerRoute = useHistoryStore((s) => s.registerRoute);\n  useEffect(() => {\n    registerRoute({ path: location.pathname });\n  }, [location.pathname, registerRoute]);\n\n  useEffectOnce(() => {\n    registerRoute({ path: location.pathname });\n  });\n}\n\nexport function useLastNonPlayerLink() {\n  const routes = useHistoryStore((s) => s.routes);\n  const location = useLocation();\n  const lastNonPlayerLink = useMemo(() => {\n    const reversedRoutes = [...routes];\n    reversedRoutes.reverse();\n    const route = reversedRoutes.find(\n      (v) =>\n        !v.path.startsWith(\"/media\") && // cannot be a player link\n        location.pathname !== v.path && // cannot be current link\n        !v.path.startsWith(\"/s/\") && // cannot be a quick search link\n        !v.path.startsWith(\"/onboarding\"), // cannot be an onboarding link\n    );\n    return route?.path ?? \"/\";\n  }, [routes, location]);\n  return lastNonPlayerLink;\n}\n"],"file":"assets/index-bxoUcoqi.js"}